{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/animate/Animator.js","src/animate/AnimatorTimeline.js","src/animate/MovieClip.js","src/animate/Scene.js","src/animate/ShapesCache.js","src/animate/SymbolLoader.js","src/animate/Timeline.js","src/animate/Tween.js","src/animate/index.js","src/animate/load.js","src/animate/sound.js","src/animate/utils.js","src/mixins/Container.js","src/mixins/DisplayObject.js","src/mixins/Graphics.js","src/mixins/Sprite.js","src/mixins/Text.js","src/mixins/index.js","index.js"],"names":[],"mappings":";;;;;;;AAAA;;;;;ACAA;;;;;;;;AAEA;AACA,IAAM,YAAY,EAAlB;;AAEA;;;;;;IAKM;;;;;AAgCF;;;;;;;;;;;;aAYO,qBAAK,UAAU,OAAO,UAAU;AACnC,YAAI,OAAO,KAAX;AACA,YAAI,cAAJ;AAAA,YAAW,YAAX;AACA,YAAM,kBAAkB,OAAO,KAAP,KAAiB,UAAzC;AACA,YAAI,UAAU,SAAV,IAAuB,eAA3B,EAA4C;AACxC,oBAAQ,CAAR;AACA,kBAAM,SAAS,WAAT,GAAuB,CAA7B;AACA,gBAAI,eAAJ,EAAqB;AACjB,2BAAW,KAAX;AACH;AACJ,SAND,MAMO;AACH,oBAAQ,SAAS,SAAT,CAAmB,KAAnB,CAAR;AACA,kBAAM,SAAS,SAAT,CAAmB,QAAQ,KAAK,UAAhC,CAAN;AACA,gBAAI,QAAQ,SAAZ,EAAuB;AACnB,sBAAM,SAAS,SAAT,CAAmB,QAAQ,KAAK,UAAhC,CAAN;AACA,uBAAO,IAAP;AACH;AACD,gBAAI,UAAU,SAAd,EAAyB;AACrB,sBAAM,IAAI,KAAJ,CAAU,8BAA8B,KAA9B,GAAsC,GAAhD,CAAN;AACH,aAFD,MAEO,IAAI,QAAQ,SAAZ,EAAuB;AAC1B,sBAAM,IAAI,KAAJ,CAAU,4BAA4B,KAA5B,GAAoC,GAA9C,CAAN;AACH;AACJ;AACD,eAAO,KAAK,MAAL,CACH,QADG,EAEH,KAFG,EAGH,GAHG,EAIH,IAJG,EAKH,QALG,CAAP;AAOH;;AAED;;;;;;;;;;;aASO,iBAAG,UAAU,KAAK,UAAU;AAC/B,eAAO,KAAK,MAAL,CACH,QADG,EAEH,SAAS,YAFN,EAGH,GAHG,EAIH,KAJG,EAKH,QALG,CAAP;AAOH;;AAED;;;;;;;;;;;;;aAWO,yBAAO,UAAU,OAAO,KAAK,MAAM,UAAU;;AAEhD,YAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,gBAAM,aAAa,KAAnB;AACA,oBAAQ,SAAS,SAAT,CAAmB,UAAnB,CAAR;AACA,gBAAI,UAAU,SAAd,EAAyB;AACrB,sBAAM,IAAI,KAAJ,CAAU,8BAA8B,UAA9B,GAA2C,GAArD,CAAN;AACH;AACJ;AACD,YAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AACzB,gBAAM,WAAW,GAAjB;AACA,kBAAM,SAAS,SAAT,CAAmB,QAAnB,CAAN;AACA,gBAAI,QAAQ,SAAZ,EAAuB;AACnB,sBAAM,IAAI,KAAJ,CAAU,4BAA4B,QAA5B,GAAuC,GAAjD,CAAN;AACH;AACJ;AACD,YAAI,QAAQ,CAAZ,EAAe;AACX,kBAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACH;AACD,YAAI,OAAO,SAAS,WAApB,EAAiC;AAC7B,kBAAM,IAAI,KAAJ,CAAU,4BAAV,CAAN;AACH;AACD,YAAI,SAAS,GAAb,EAAkB;AACd,kBAAM,IAAI,KAAJ,CAAU,iCAAV,CAAN;AACH;;AAED;AACA,aAAK,IAAL,CAAU,QAAV;;AAEA,eAAO,CAAC,CAAC,IAAT;;AAEA;AACA,YAAM,WAAW,2BAAiB,MAAjB,CACb,QADa,EAEb,KAFa,EAGb,GAHa,EAIb,IAJa,EAKb,QALa,CAAjB;AAOA,aAAK,UAAL,CAAgB,IAAhB,CAAqB,QAArB;;AAEA;AACA,YAAI,SAAS,YAAT,KAA0B,KAA9B,EAAqC;AACjC,qBAAS,WAAT,CAAqB,KAArB;AACH,SAFD,MAEO;AACH,qBAAS,IAAT;AACH;AACD,eAAO,QAAP;AACH;;AAED;;;;;;;;aAMO,qBAAK,UAAU;AAClB,aAAK,IAAI,IAAI,CAAR,EAAW,MAAM,KAAK,UAAL,CAAgB,MAAtC,EAA8C,IAAI,GAAlD,EAAuD,GAAvD,EAA4D;AACxD,gBAAM,WAAW,KAAK,UAAL,CAAgB,CAAhB,CAAjB;AACA,gBAAI,SAAS,QAAT,KAAsB,QAA1B,EAAoC;AAChC,qBAAK,aAAL,CAAmB,QAAnB;AACA;AACH;AACJ;AACJ;;AAED;;;;;;;aAKO,6BAAU;AACb,aAAK,IAAI,IAAI,KAAK,UAAL,CAAgB,MAAhB,GAAyB,CAAtC,EAAyC,KAAK,CAA9C,EAAiD,GAAjD,EAAsD;AAClD,iBAAK,aAAL,CAAmB,KAAK,UAAL,CAAgB,CAAhB,CAAnB;AACH;AACJ;;AAED;;;;;;;;;aAOO,uCAAc,UAAU;AAC3B,aAAK,UAAL,CAAgB,MAAhB,CAAuB,KAAK,UAAL,CAAgB,OAAhB,CAAwB,QAAxB,CAAvB,EAA0D,CAA1D;AACA,iBAAS,QAAT,CAAkB,IAAlB;AACA,iBAAS,OAAT;AACH;;;;;;AAhMD;;;;;;4BAMwB;AACpB,mBAAO,SAAP;AACH;;AAED;;;;;;;;;4BAMwB;AACpB,mBAAO,OAAP;AACH;;AAED;;;;;;;;;4BAMwB;AACpB,mBAAO,OAAP;AACH;;;;;;AAuKL,OAAO,OAAP,GAAiB,QAAjB;;;;;;;;;AC/MA,IAAM,OAAO,EAAb;;AAEA;;;;;;IAKM;AACF,gCAAc;AAAA;;AACV,aAAK,OAAL,GAAe,KAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB,CAAf;AACA,aAAK,IAAL,CAAU,IAAV,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,KAAtB,EAA6B,IAA7B;AACH;;AAED;;;;;;;;;;;;+BAUA,qBAAK,UAAU,OAAO,KAAK,MAAM,UAAU;;AAEvC;;;;;;AAMA,aAAK,QAAL,GAAgB,QAAhB;;AAEA;;;;;;AAMA,aAAK,IAAL,GAAY,IAAZ;;AAEA;;;;;;AAMA,aAAK,KAAL,GAAa,KAAb;;AAEA;;;;;;AAMA,aAAK,GAAL,GAAW,GAAX;;AAEA;;;;;;AAMA,aAAK,QAAL,GAAgB,QAAhB;;AAEA,YAAI,QAAJ,EAAc;AACV,qBAAS,WAAT,CAAqB,KAArB;AACA,qBAAS,aAAT,GAAyB,KAAK,OAA9B;AACH;AACJ;;AAED;;;;;;;+BAKA,6BAAU;AACN,aAAK,QAAL,CAAc,aAAd,GAA8B,IAA9B;AACA,aAAK,IAAL,CAAU,IAAV,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,KAAtB,EAA6B,IAA7B;AACA,yBAAiB,KAAjB,CAAuB,IAAvB,CAA4B,IAA5B;AACH;;AAED;;;;;;;;;+BAOA,yBAAO,UAAU;AACb,YAAI,kBAAJ;AACA,YAAI,SAAS,YAAT,IAAyB,KAAK,GAAlC,EAAuC;;AAEnC;AACA,qBAAS,YAAT,GAAwB,KAAK,GAA7B;;AAEA,gBAAI,KAAK,IAAT,EAAe;AACX;AACA,yBAAS,eAAT;AACA,yBAAS,WAAT,CAAqB,KAAK,KAA1B;AACH,aAJD,MAIO;AACH,yBAAS,IAAT;AACA,oBAAI,KAAK,QAAT,EAAmB;AACf,gCAAY,KAAK,QAAjB;AACH;AACD,qBAAK,IAAL,GALG,CAKU;AAChB;AACJ;AACD,eAAO,SAAP;AACH;;AAED;;;;;;+BAIA,uBAAO;AACH,aAAK,OAAL,CAAa,QAAb,CAAsB,aAAtB,CAAoC,IAApC;AACH;;AAED;;;;;;;;AAsBA;;;;;;;;;;;qBAWO,yBAAO,UAAU,OAAO,KAAK,MAAM,UAAU;AAChD,YAAI,QAAJ;AACA,YAAI,KAAK,KAAL,CAAW,MAAf,EAAuB;AACnB,uBAAW,KAAK,KAAL,CAAW,GAAX,EAAX;AACH,SAFD,MAEO;AACH,uBAAW,IAAI,gBAAJ,EAAX;AACH;AACD,iBAAS,IAAT,CAAc,QAAd,EAAwB,KAAxB,EAA+B,GAA/B,EAAoC,IAApC,EAA0C,QAA1C;AACA,eAAO,QAAP;AACH;;;;4BApCc;AACX,gBAAM,WAAW,CAAC,KAAK,QAAL,CAAc,YAAd,GAA6B,KAAK,KAAnC,KAA6C,KAAK,GAAL,GAAW,KAAK,KAA7D,CAAjB;AACA,mBAAO,KAAK,GAAL,CAAS,CAAT,EAAY,KAAK,GAAL,CAAS,CAAT,EAAY,QAAZ,CAAZ,CAAP,CAFW,CAEgC;AAC9C;;AAED;;;;;;;;;;4BAOmB;AACf,mBAAO,IAAP;AACH;;;;;;AAyBL,OAAO,OAAP,GAAiB,gBAAjB;;;;;;;;;ACpKA;;;;AACA;;;;;;;;;;;;AAEA,IAAM,YAAY,KAAK,SAAvB;AACA,IAAM,eAAe,KAAK,MAAL,CAAY,MAAjC;;AAEA;;;;;;;;;;;;;;;IAcM;;;AACF,uBAAY,OAAZ,EAAqB,QAArB,EAA+B,IAA/B,EAAqC,SAArC,EAAgD,MAAhD,EAAwD;AAAA;;AAGpD;AAHoD,qDACpD,qBADoD;;AAIpD,kBAAU,YAAY,SAAZ,GAAwB,EAAxB,GAA6B,OAAvC;;AAEA;AACA,YAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC7B,sBAAU;AACN,sBAAM,WAAW,UAAU,WADrB;AAEN,0BAAU,YAAY,CAFhB;AAGN,sBAAM,SAAS,SAAT,GAAqB,IAArB,GAA4B,IAH5B;AAIN,wBAAQ,UAAU,EAJZ;AAKN,2BAAW,aAAa,CALlB;AAMN,+BAAe;AANT,aAAV;AAQH,SATD,MASO;AACH;AACA,sBAAU,OAAO,MAAP,CAAc;AACpB,sBAAM,UAAU,WADI;AAEpB,+BAAe,CAFK;AAGpB,sBAAM,IAHc;AAIpB,wBAAQ,EAJY;AAKpB,0BAAU,CALU;AAMpB,2BAAW;AANS,aAAd,EAOP,OAPO,CAAV;AAQH;;AAED;;;;;;;AAOA,cAAK,IAAL,GAAY,QAAQ,IAApB;;AAEA;;;;;;AAMA,cAAK,aAAL,GAAqB,QAAQ,aAA7B;;AAEA;;;;;;AAMA,cAAK,IAAL,GAAY,CAAC,CAAC,QAAQ,IAAtB;;AAEA;;;;;;;AAOA,cAAK,YAAL,GAAoB,CAApB;;AAEA;;;;;;AAMA,cAAK,OAAL,GAAe,EAAf;;AAEA;;;;;;AAMA,cAAK,UAAL,GAAkB,QAAQ,MAA1B;AACA,YAAI,QAAQ,MAAZ,EAAoB;AAChB,iBAAK,IAAI,IAAT,IAAiB,QAAQ,MAAzB,EAAiC;AAC7B,oBAAI,QAAQ;AACR,2BAAO,IADC;AAER,8BAAU,QAAQ,MAAR,CAAe,IAAf;AAFF,iBAAZ;AAIA,sBAAK,OAAL,CAAa,IAAb,CAAkB,KAAlB;AACH;AACD,kBAAK,OAAL,CAAa,IAAb,CAAkB,UAAS,CAAT,EAAY,CAAZ,EAAe;AAC7B,uBAAO,EAAE,QAAF,GAAa,EAAE,QAAtB;AACH,aAFD;AAGH;;AAED;;;;;;AAMA,cAAK,WAAL,GAAmB,IAAnB;;AAEA;;;;;;AAMA,cAAK,MAAL,GAAc,KAAd;;AAEA;;;;;;AAMA,cAAK,cAAL,GAAsB,IAAtB;;AAEA;;;;;;;;;;;;AAYA,cAAK,SAAL,GAAiB,IAAjB;;AAEA;;;;;;AAMA,cAAK,YAAL,GAAoB,CAApB;;AAEA;;;;;;AAMA,cAAK,QAAL,GAAgB,CAAC,CAAjB,CA9IoD,CA8IhC;;AAEpB;;;;;;;;AAQA,cAAK,EAAL,GAAU,CAAV;;AAEA;;;;;;;;;;AAUA,cAAK,UAAL,GAAkB,QAAQ,SAA1B;;AAEA;;;;;;;AAOA,cAAK,SAAL,GAAiB,CAAjB;;AAEA;;;;;;;AAOA,cAAK,YAAL,GAAoB,QAAQ,QAA5B;;AAEA;;;;;;;AAOA,cAAK,UAAL,GAAkB,EAAlB;;AAEA;;;;;;;;AAQA,cAAK,oBAAL,GAA4B,EAA5B;;AAEA;;;;;;AAMA,cAAK,YAAL,GAAoB,EAApB;;AAEA;;;;;;AAMA,cAAK,QAAL,GAAgB,EAAhB;;AAEA;;;;;;;AAOA,cAAK,aAAL,GAAqB,IAArB;;AAEA,YAAI,MAAK,IAAL,KAAc,UAAU,WAA5B,EAAyC;AACrC,kBAAK,aAAL,GAAqB,MAAK,aAAL,CAAmB,IAAnB,OAArB;AACA,kBAAK,QAAL,GAAgB,MAAK,QAAL,CAAc,IAAd,OAAhB;AACA,kBAAK,UAAL,GAAkB,MAAK,UAAL,CAAgB,IAAhB,OAAlB;AACA,kBAAK,EAAL,CAAQ,OAAR,EAAiB,MAAK,QAAtB;AACA,kBAAK,EAAL,CAAQ,SAAR,EAAmB,MAAK,UAAxB;AACH;;AAED,YAAI,QAAQ,SAAZ,EAAuB;AACnB,kBAAK,SAAL,GAAiB,QAAQ,SAAzB;AACH;;AAED;AACA;AACA,cAAK,OAAL,GAAe,MAAK,OAApB;AACA,cAAK,eAAL,GAAuB,MAAK,eAA5B;AACA,cAAK,oBAAL,GAA4B,MAAK,oBAAjC;AACA,cAAK,KAAL,GAAa,MAAK,KAAlB;AArPoD;AAsPvD;;wBAED,+BAAW;AACP,YAAI,CAAC,KAAK,UAAV,EAAsB;AAClB,iBAAK,SAAL,GAAiB,KAAK,eAAtB;AACH;AACD,qBAAa,GAAb,CAAiB,KAAK,aAAtB;AACH;;wBAED,uCAAc,iBAAiB;AAC3B,YAAI,KAAK,MAAL,IAAe,CAAC,KAAK,WAAzB,EAAsC;AAClC;AACA,gBAAI,KAAK,QAAL,GAAgB,CAApB,EAAuB;AACnB,qBAAK,KAAL,CAAW,KAAK,YAAhB;AACH;AACD;AACH;AACD,YAAI,UAAU,kBAAkB,aAAa,KAA/B,GAAuC,KAAK,QAAL,CAAc,WAArD,GAAmE,IAAjF;AACA,aAAK,OAAL,CAAa,OAAb;AACH;;wBAED,mCAAa;AACT,qBAAa,MAAb,CAAoB,KAAK,aAAzB;AACH;;AAED;;;;;;;;AA6FA;;;;;;wBAMA,mCAAY,UAAU;AAClB,YAAI,KAAK,YAAL,GAAoB,QAAxB,EAAkC;AAC9B,iBAAK,YAAL,GAAoB,QAApB;AACH;AACJ;;AAED;;;;;;;;wBAMA,6CAAiB,YAAY;AACzB;AACA,YAAI,OAAO,WAAW,CAAlB,KAAwB,QAA5B,EAAsC;AAClC,uBAAW,CAAX,GAAe,gBAAM,SAAN,CAAgB,WAAW,CAA3B,CAAf;AACH,SAFD,MAEO,IAAI,OAAO,WAAW,CAAlB,KAAwB,QAA5B,EAAsC;AACzC,uBAAW,CAAX,GAAe,CAAC,CAAC,WAAW,CAA5B;AACH;AACJ;;AAED;;;;;;;;;wBAOA,+CAAkB,UAAU;AACxB,aAAK,IAAI,IAAI,KAAK,UAAL,CAAgB,MAAhB,GAAyB,CAAtC,EAAyC,KAAK,CAA9C,EAAiD,EAAE,CAAnD,EAAsD;AAClD,gBAAI,KAAK,UAAL,CAAgB,CAAhB,EAAmB,MAAnB,KAA8B,QAAlC,EAA4C;AACxC,uBAAO,KAAK,UAAL,CAAgB,CAAhB,CAAP;AACH;AACJ;AACD,YAAI,WAAW,uBAAa,QAAb,CAAf;AACA,aAAK,UAAL,CAAgB,IAAhB,CAAqB,QAArB;AACA,eAAO,QAAP;AACH;;AAED;;;;;;;;;wBAOA,qCAAa,UAAU,WAAW;AAC9B,aAAK,IAAI,CAAT,IAAc,SAAd,EAAyB;AACrB,iBAAK,WAAL,CAAiB,QAAjB,EAA2B;AACvB,mBAAG,UAAU,CAAV;AADoB,aAA3B,EAEG,SAAS,CAAT,EAAY,EAAZ,CAFH;AAGH;;AAED;AACA,aAAK,oBAAL,CAA0B,KAAK,YAA/B,EAA6C,KAAK,YAAlD,EAAgE,IAAhE;AACA,eAAO,IAAP;AACH;;AAED;;;;;;;;;wBAOA,iBAAG,UAAU,WAAW;AACpB,eAAO,KAAK,YAAL,CAAkB,QAAlB,EAA4B,SAA5B,CAAP;AACH;;AAED;;;;;;;;;;;;;wBAWA,6BAAS,UAAU,YAAY,YAAY,UAAU,MAAM;;AAEvD,YAAI,WAAW,KAAK,iBAAL,CAAuB,QAAvB,CAAf;AACA,aAAK,gBAAL,CAAsB,UAAtB;AACA,iBAAS,QAAT,CAAkB,UAAlB,EAA8B,UAA9B,EAA0C,QAA1C,EAAoD,IAApD;AACA,aAAK,WAAL,CAAiB,aAAa,QAA9B;AACA,eAAO,IAAP;AACH;;AAED;;;;;;;;;;;;;wBAWA,mCAAY,UAAU,YAAY,YAAY;;AAE1C,YAAI,WAAW,KAAK,iBAAL,CAAuB,QAAvB,CAAf;AACA,aAAK,gBAAL,CAAsB,UAAtB;AACA,iBAAS,WAAT,CAAqB,UAArB,EAAiC,UAAjC;AACA,aAAK,WAAL,CAAiB,UAAjB;AACA,eAAO,IAAP;AACH;;AAED;;;;;;;wBAKA,iBAAG,UAAU,YAAY,UAAU,WAAW;AAC1C,eAAO,KAAK,aAAL,CAAmB,QAAnB,EAA6B,UAA7B,EAAyC,QAAzC,EAAmD,SAAnD,CAAP;AACH;;AAED;;;;;;;;;;;wBASA,uCAAc,UAAU,YAAY,UAAU,WAAW;;AAErD,YAAI,eAAe,SAAnB,EAA8B;AAC9B;AACI,6BAAa,CAAb;AACH;AACD,YAAI,aAAa,SAAb,IAA0B,WAAW,CAAzC,EAA4C;AAC5C;AACI,2BAAW,KAAK,YAAL,IAAqB,CAAhC;AACH;;AAED;AACA,YAAI,SAAS,IAAT,KAAkB,UAAU,OAAhC,EAAyC;AACrC,qBAAS,mBAAT,GAA+B,UAA/B;AACH;;AAED;AACA;AACA;AACA,YAAI,iBAAJ;AAAA,YAAc,UAAd;AACA;AACA,aAAK,IAAI,KAAK,oBAAL,CAA0B,MAA1B,GAAmC,CAA5C,EAA+C,KAAK,CAApD,EAAuD,EAAE,CAAzD,EAA4D;AACxD,gBAAI,KAAK,oBAAL,CAA0B,CAA1B,EAA6B,MAA7B,KAAwC,QAA5C,EAAsD;AAClD,2BAAW,KAAK,oBAAL,CAA0B,CAA1B,CAAX;AACA;AACH;AACJ;AACD;AACA,YAAI,CAAC,QAAL,EAAe;AACX,uBAAW,EAAX;AACA,qBAAS,MAAT,GAAkB,QAAlB;AACA,iBAAK,oBAAL,CAA0B,IAA1B,CAA+B,QAA/B;AACH;;AAED;AACA,wBAAM,UAAN,CAAiB,QAAjB,EAA2B,UAA3B,EAAuC,QAAvC;;AAEA;AACA;AACA,YAAI,KAAK,YAAL,GAAoB,aAAa,QAArC,EAA+C;AAC3C,iBAAK,YAAL,GAAoB,aAAa,QAAjC;AACH;;AAED;AACA,YAAI,SAAJ,EAAe;AACX,gBAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AAC/B,4BAAY,gBAAM,oBAAN,CAA2B,SAA3B,CAAZ;AACH;AACD;AACA;AACA,gBAAI,YAAY,EAAhB;AACA,iBAAK,IAAI,EAAT,IAAc,SAAd,EAAyB;AACrB,4BAAY,OAAO,MAAP,CAAc,EAAd,EAAkB,SAAlB,EAA6B,UAAU,EAAV,CAA7B,CAAZ;AACA,qBAAK,WAAL,CAAiB,QAAjB,EAA2B,SAA3B,EAAsC,SAAS,EAAT,EAAY,EAAZ,CAAtC;AACH;AACD,iBAAK,iBAAL,CAAuB,QAAvB,EACK,eADL,CACqB,aAAa,QADlC;AAEH;;AAED;AACA,aAAK,oBAAL,CAA0B,UAA1B,EAAsC,KAAK,YAA3C,EAAyD,IAAzD;;AAEA,eAAO,IAAP;AACH;;AAED;;;;;;;;;wBAOA,iBAAG,UAAU,YAAY;AACrB,eAAO,KAAK,SAAL,CAAe,QAAf,EAAyB,UAAzB,CAAP;AACH;;AAED;;;;;;;;;wBAOA,+BAAU,UAAU,YAAY;;AAE5B,YAAI,OAAO,UAAP,KAAsB,QAA1B,EAAoC;AAChC,gBAAM,QAAQ,KAAK,UAAL,CAAgB,UAAhB,CAAd;AACA,gBAAI,UAAU,SAAd,EAAyB;AACrB,uCAAoB,UAApB;AACH;AACD,yBAAa,KAAb;AACH;;AAED,YAAI,UAAU,KAAK,QAAnB;AACA;AACA,YAAI,QAAQ,MAAR,IAAkB,UAAtB,EAAkC;AAC9B,oBAAQ,MAAR,GAAiB,aAAa,CAA9B;AACH;AACD,YAAI,KAAK,YAAL,GAAoB,UAAxB,EAAoC;AAChC,iBAAK,YAAL,GAAoB,UAApB;AACH;AACD;AACA,YAAI,QAAQ,UAAR,CAAJ,EAAyB;AACrB,oBAAQ,UAAR,EAAoB,IAApB,CAAyB,QAAzB;AACH,SAFD,MAEO;AACH,oBAAQ,UAAR,IAAsB,CAAC,QAAD,CAAtB;AACH;AACD,eAAO,IAAP;AACH;;AAED;;;;;;;;;;wBAQA,iBAAG,OAAO,MAAM;AACZ,eAAO,KAAK,SAAL,CAAe,KAAf,EAAsB,IAAtB,CAAP;AACH;;AAED;;;;;;;;;;wBAQA,+BAAU,OAAO,MAAM;AACnB,aAAK,OAAL,CAAa,KAAb,CAAmB,IAAnB,CAAwB,MAAxB,EAAgC,KAAhC,EAAuC,CAAC,CAAC,IAAzC,EAA+C,IAA/C;AACA,eAAO,IAAP;AACH;;AAED;;;;;;wBAIA,uBAAO;AACH,aAAK,MAAL,GAAc,KAAd;AACH;;AAED;;;;;;wBAIA,uBAAO;AACH,aAAK,MAAL,GAAc,IAAd;AACH;;AAED;;;;;;;wBAKA,mCAAY,iBAAiB;AACzB,aAAK,MAAL,GAAc,KAAd;AACA,aAAK,KAAL,CAAW,eAAX;AACH;;AAED;;;;;;;wBAKA,mCAAY,iBAAiB;AACzB,aAAK,MAAL,GAAc,IAAd;AACA,aAAK,KAAL,CAAW,eAAX;AACH;;AAED;;;;;;;;AAiBA;;;;;wBAKA,2BAAQ,MAAM;;AAEV;AACA;AACA,YAAI,CAAC,KAAK,UAAV,EAAsB;AAClB,iBAAK,SAAL,GAAiB,KAAK,eAAtB;AACH;;AAED,YAAI,IAAJ,EAAU;AACN,iBAAK,EAAL,IAAW,IAAX;AACH;AACD,YAAI,KAAK,EAAL,GAAU,KAAK,SAAnB,EAA8B;AAC1B,iBAAK,EAAL,GAAU,KAAK,IAAL,GAAY,KAAK,EAAL,GAAU,KAAK,SAA3B,GAAuC,KAAK,SAAtD;AACH;AACD;AACA,aAAK,YAAL,GAAoB,KAAK,KAAL,CAAW,KAAK,EAAL,GAAU,KAAK,UAAf,GAA4B,UAAvC,CAApB;AACA;AACA,YAAI,KAAK,YAAL,IAAqB,KAAK,YAA9B,EAA4C;AACxC,iBAAK,YAAL,GAAoB,KAAK,YAAL,GAAoB,CAAxC;AACH;AACD,YAAI,wBAAJ;AACA,YAAI,KAAK,aAAT,EAAwB;AACpB,8BAAkB,KAAK,aAAL,CAAmB,IAAnB,CAAlB;AACH;AACD;AACA,aAAK,eAAL;;AAEA;AACA,YAAI,eAAJ,EAAqB;AACjB;AACH;AACJ;;AAED;;;;;;;wBAKA,uBAAM,iBAAiB;AACnB,YAAI,MAAM,OAAO,eAAP,KAA2B,QAA3B,GAAsC,KAAK,UAAL,CAAgB,eAAhB,CAAtC,GAAyE,eAAnF;AACA,YAAI,QAAQ,SAAZ,EAAuB;AACvB;AACI;AACH;AACD;AACA,aAAK,QAAL,GAAgB,GAAhB;AACA,aAAK,YAAL,GAAoB,GAApB;;AAEA;AACA;AACA,YAAI,CAAC,KAAK,UAAV,EAAsB;AAClB,iBAAK,SAAL,GAAiB,KAAK,eAAtB;AACH;;AAED;AACA,YAAI,KAAK,UAAL,GAAkB,CAAtB,EAAyB;AACrB,iBAAK,EAAL,GAAU,MAAM,KAAK,UAArB;AACH,SAFD,MAEO;AACH,iBAAK,EAAL,GAAU,CAAV;AACH;AACD,aAAK,eAAL;AACH;;AAED;;;;;;wBAIA,2BAAS;AACL,aAAK,QAAL,GAAgB,CAAC,CAAjB;AACA,aAAK,EAAL,GAAU,CAAV;AACA,aAAK,YAAL,GAAoB,CAApB;AACH;;AAED;;;;;;wBAIA,6CAAkB;AACd,YAAI,UAAU,KAAK,IAAL,KAAc,UAAU,WAAtC;;AAEA,YAAI,OAAJ,EAAa;AACT,iBAAK,YAAL,GAAoB,KAAK,aAAL,IAAsB,KAAK,IAAL,KAAc,UAAU,YAAxB,GAAuC,CAAvC,GAA2C,KAAK,YAAtE,CAApB;AACA,gBAAI,KAAK,YAAL,IAAqB,KAAK,YAA9B,EAA4C;AACxC,qBAAK,YAAL,IAAqB,KAAK,YAA1B;AACH;AACJ;;AAED,YAAI,KAAK,QAAL,KAAkB,KAAK,YAA3B,EAAyC;AACrC;AACH;;AAED;AACA,aAAK,oBAAL,CAA0B,KAAK,QAA/B,EAAyC,KAAK,YAA9C,EAA4D,UAAU,KAAV,GAAkB,KAAK,cAAnF;;AAEA,aAAK,QAAL,GAAgB,KAAK,YAArB;AACH;;AAED;;;;;;;;;;wBAQA,qDAAqB,YAAY,cAAc,WAAW;AACtD;AACA,YAAI,UAAJ;AAAA,YAAO,UAAP;AAAA,YAAU,eAAV;AAAA,YAAkB,aAAa,KAAK,UAApC;AACA,aAAK,IAAI,WAAW,MAAX,GAAoB,CAA7B,EAAgC,KAAK,CAArC,EAAwC,EAAE,CAA1C,EAA6C;AACzC,gBAAI,WAAW,WAAW,CAAX,CAAf;AACA,iBAAK,IAAI,CAAJ,EAAO,SAAS,SAAS,MAA9B,EAAsC,IAAI,MAA1C,EAAkD,EAAE,CAApD,EAAuD;AACnD,oBAAI,QAAQ,SAAS,CAAT,CAAZ;AACA;AACA,oBAAI,gBAAgB,MAAM,UAAtB,IACA,gBAAgB,MAAM,QAD1B,EACoC;AAChC;AACA;AACA,0BAAM,WAAN,CAAkB,YAAlB;AACA;AACH;AACJ;AACJ;;AAED,YAAI,sBAAsB,KAAK,oBAA/B;AACA,YAAI,cAAc,KAAK,YAAvB;AACA,aAAK,IAAI,CAAJ,EAAO,SAAS,oBAAoB,MAAzC,EAAiD,IAAI,MAArD,EAA6D,EAAE,CAA/D,EAAkE;AAC9D,gBAAI,SAAS,oBAAoB,CAApB,EAAuB,MAApC;AACA,gBAAI,gBAAgB,oBAAoB,CAApB,EAAuB,YAAvB,CAApB;AACA;AACA,gBAAI,aAAJ,EAAmB;AACf;AACA;AACA,4BAAY,IAAZ,CAAiB,MAAjB;AACA,oBAAI,OAAO,MAAP,KAAkB,IAAtB,EAA4B;AACxB;AACA,yBAAK,QAAL,CAAc,MAAd;AACA,wBAAI,OAAO,IAAP,KAAgB,UAAU,WAA1B,IAAyC,OAAO,SAApD,EAA+D;AAC3D,+BAAO,MAAP;AACH;AACJ;AACJ,aAXD,MAWO,IAAI,CAAC,aAAD,IAAkB,OAAO,MAAP,KAAkB,IAAxC,EAA8C;AACjD,qBAAK,WAAL,CAAiB,MAAjB;AACH;AACJ;;AAED;AACA,aAAK,IAAI,CAAJ,EAAO,SAAS,YAAY,MAAjC,EAAyC,IAAI,MAA7C,EAAqD,GAArD,EAA0D;AACtD,gBAAI,UAAS,YAAY,CAAZ,CAAb;AACA,gBAAI,eAAe,KAAK,QAAL,CAAc,OAAd,CAAsB,OAAtB,CAAnB;AACA,gBAAI,iBAAiB,CAArB,EAAwB;AACpB,qBAAK,UAAL,CAAgB,OAAhB,EAAwB,CAAxB;AACH;AACJ;;AAED;AACA,oBAAY,MAAZ,GAAqB,CAArB;;AAEA;AACA,YAAI,WAAW,KAAK,QAApB;AAAA,YACI,cADJ;AAEA,aAAK,IAAI,CAAJ,EAAO,SAAS,SAAS,MAA9B,EAAsC,IAAI,MAA1C,EAAkD,EAAE,CAApD,EAAuD;AACnD,oBAAQ,SAAS,CAAT,CAAR;AACA,gBAAI,MAAM,IAAN,KAAe,UAAU,OAA7B,EAAsC;AAClC,sBAAM,YAAN,GAAqB,eAAe,MAAM,mBAA1C;AACA,sBAAM,eAAN;AACH;AACJ;;AAED;AACA,YAAI,SAAJ,EAAe;AACX,gBAAI,UAAU,KAAK,QAAnB;AACA;AACA,gBAAI,YAAY,KAAhB;AACA,gBAAI,eAAe,UAAnB,EAA+B;AAC3B,yBAAS,QAAQ,MAAjB;AACA,4BAAY,IAAZ;AACH,aAHD,MAGO;AACH,yBAAS,KAAK,GAAL,CAAS,eAAe,CAAxB,EAA2B,QAAQ,MAAnC,CAAT;AACH;AACD,iBAAK,IAAI,cAAc,CAAd,GAAkB,aAAa,CAA/B,GAAmC,YAA5C,EAA0D,IAAI,MAA9D,EAAsE,EAAE,CAAxE,EAA2E;AACvE,oBAAI,QAAQ,CAAR,CAAJ,EAAgB;AACZ,wBAAI,eAAe,QAAQ,CAAR,CAAnB;AACA,yBAAK,IAAI,CAAT,EAAY,IAAI,aAAa,MAA7B,EAAqC,EAAE,CAAvC,EAA0C;AACtC,qCAAa,CAAb,EAAgB,IAAhB,CAAqB,IAArB;AACH;AACJ;AACD;AACA,oBAAI,aAAa,MAAM,SAAS,CAAhC,EAAmC;AAC/B,wBAAI,CAAJ;AACA,6BAAS,eAAe,CAAxB;AACA,gCAAY,KAAZ;AACH;AACJ;AACJ;AACJ;;wBAED,2BAAQ,iBAAiB;AACrB,YAAI,KAAK,aAAT,EAAwB;AACpB,yBAAa,MAAb,CAAoB,KAAK,aAAzB;AACA,iBAAK,aAAL,GAAqB,IAArB;AACH;AACD,YAAM,iBAAiB,EAAvB;AACA,YAAI,YAAY,KAAK,UAArB;AACA,YAAI,SAAJ,EAAe;AACX,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,UAAU,MAA9B,EAAsC,GAAtC,EAA2C;AACvC,oBAAM,WAAW,UAAU,CAAV,CAAjB;AACA,+BAAe,IAAf,CAAoB,SAAS,MAA7B;AACA,yBAAS,aAAT,GAAyB,IAAzB;AACA,yBAAS,MAAT,GAAkB,CAAlB;AACH;AACJ;AACD,oBAAY,KAAK,oBAAjB;AACA,YAAI,SAAJ,EAAe;AACX,iBAAK,IAAI,MAAI,CAAb,EAAgB,MAAI,UAAU,MAA9B,EAAsC,KAAtC,EAA2C;AACvC,oBAAM,YAAW,UAAU,GAAV,CAAjB;AACA,oBAAI,eAAe,OAAf,CAAuB,UAAS,MAAhC,IAA0C,CAA9C,EAAiD;AAC7C,mCAAe,IAAf,CAAoB,UAAS,MAA7B;AACH;AACD,0BAAS,aAAT,GAAyB,IAAzB;AACA,0BAAS,MAAT,GAAkB,CAAlB;AACH;AACJ;AACD;AACA,aAAK,IAAI,MAAI,CAAb,EAAgB,MAAI,eAAe,MAAnC,EAA2C,KAA3C,EAAgD;AAC5C;AACA,gBAAI,KAAK,QAAL,CAAc,OAAd,CAAsB,eAAe,GAAf,CAAtB,IAA2C,CAA/C,EAAkD;AAC9C,+BAAe,GAAf,EAAkB,OAAlB,CAA0B,eAA1B;AACH;AACJ;AACD,uBAAe,MAAf,GAAwB,CAAxB;AACA,aAAK,QAAL,GAAgB,IAAhB;AACA,aAAK,UAAL,GAAkB,IAAlB;AACA,aAAK,YAAL,GAAoB,IAApB;AACA,aAAK,oBAAL,GAA4B,IAA5B;AACA,aAAK,aAAL,GAAqB,IAArB;AACA,aAAK,OAAL,GAAe,IAAf;AACA,aAAK,UAAL,GAAkB,IAAlB;AACA,6BAAM,OAAN,YAAc,eAAd;AACH;;;;4BA3oBY;AACT,mBAAO,KAAK,OAAZ;AACH;;AAED;;;;;;;;;4BAMgB;AACZ,mBAAO,KAAK,UAAZ;AACH;;AAED;;;;;;;;;4BAMmB;AACf,gBAAI,SAAS,KAAK,OAAlB;AACA,gBAAI,UAAU,IAAd;AACA,iBAAK,IAAI,IAAI,CAAR,EAAW,MAAM,OAAO,MAA7B,EAAqC,IAAI,GAAzC,EAA8C,EAAE,CAAhD,EAAmD;AAC/C,oBAAI,OAAO,CAAP,EAAU,QAAV,IAAsB,KAAK,YAA/B,EAA6C;AACzC,8BAAU,OAAO,CAAP,EAAU,KAApB;AACH,iBAFD,MAEO;AACH;AACH;AACJ;AACD,mBAAO,OAAP;AACH;;AAED;;;;;;;;;;4BAOkB;AACd,mBAAO,KAAK,EAAZ;AACH;0BAEe,OAAO;AACnB,iBAAK,EAAL,GAAU,KAAV;AACH;;AAED;;;;;;;;;;;;;;;;;;4BAegB;AACZ,mBAAO,KAAK,UAAZ;AACH;0BACa,OAAO;AACjB,gBAAI,QAAQ,CAAZ,EAAe;AACX,qBAAK,UAAL,GAAkB,KAAlB;AACA,qBAAK,SAAL,GAAiB,QAAQ,KAAK,YAAL,GAAoB,KAA5B,GAAoC,CAArD;AACA,qBAAK,EAAL,GAAU,KAAK,YAAL,GAAoB,KAA9B;AACH,aAJD,MAIO;AACH,qBAAK,EAAL,GAAU,KAAK,UAAL,GAAkB,KAAK,SAAL,GAAiB,CAA7C;AACH;AACJ;;AAED;;;;;;;;;;4BAOkB;AACd,mBAAO,KAAK,YAAZ;AACH;;;4BAwTqB;AAClB,gBAAI,IAAI,IAAR;AAAA,gBACI,MAAM,EAAE,UADZ;AAEA,mBAAO,CAAC,IAAI,EAAE,MAAP,KAAkB,CAAC,GAA1B,EAA+B;AAC3B,oBAAI,EAAE,IAAF,KAAW,UAAU,WAAzB,EAAsC;AAClC,0BAAM,EAAE,UAAR;AACH;AACJ;AACD,mBAAO,OAAO,UAAU,iBAAxB;AACH;;;;EA5qBmB;;AAo6BxB;;;;;;;;;;;AASA,UAAU,WAAV,GAAwB,CAAxB;;AAEA;;;;;;;;AAQA,UAAU,YAAV,GAAyB,CAAzB;;AAEA;;;;;;;;;AASA,UAAU,OAAV,GAAoB,CAApB;;AAGA;;;;;;;;AAQA,UAAU,iBAAV,GAA8B,EAA9B;;AAEA;;;;;;;AAOA;;;;;;;AAOA,UAAU,MAAV,GAAmB,UAAU,CAAV,GAAc,UAAS,KAAT,EAAgB;AAC7C,UAAM,SAAN,GAAkB,OAAO,MAAP,CAAc,UAAU,SAAxB,CAAlB;AACA,UAAM,SAAN,CAAgB,QAAhB,GAA2B,UAAU,SAArC;AACA,UAAM,SAAN,CAAgB,WAAhB,GAA8B,KAA9B;AACA,WAAO,KAAP;AACH,CALD;;AAOA;kBACe;;;;;;;ACz/Bf;;;;AACA;;;;;;;;;;;;AAEA;;;;;;;;;;;;;IAaM;;;AAEL,gBAAY,KAAZ,EAAmB,MAAnB,EAA2B,aAA3B,EAA0C,OAA1C,EAAmD;AAAA;;AAGlD;;;;;;AAHkD,+CAClD,6BAAM,KAAN,EAAa,MAAb,EAAqB,aAArB,EAAoC,OAApC,CADkD;;AASlD,QAAK,KAAL;;AAEA;;;;;;AAMA,QAAK,QAAL,GAAgB,IAAhB;AAjBkD;AAkBlD;;AAED;;;;;;;;;;iBAQA,qBAAK,UAAU,UAAU,UAAU;AAAA;;AAClC,SAAO,oBAAK,QAAL,EAAe,KAAK,KAApB,EAA2B,UAAC,QAAD,EAAc;AAC/C,UAAK,QAAL,GAAgB,QAAhB;AACA,OAAI,QAAJ,EAAc;AACb,aAAS,QAAT;AACA;AACD,GALM,EAKJ,QALI,CAAP;AAMA;;AAED;;;;;;;iBAKA,2BAAQ,YAAY;AACnB,MAAI,KAAK,QAAT,EAAmB;AAClB,QAAK,QAAL,CAAc,OAAd,CAAsB,IAAtB;AACA,QAAK,QAAL,GAAgB,IAAhB;AACA;AACD,8BAAM,OAAN,YAAc,UAAd;AACA;;;EAlDkB,KAAK;;kBAqDV;;;;;;;;;ACrEf;;;;;;AAEA;;;;;AAKA,IAAM,cAAc,EAApB;;AAEA;;;;;;;AAOA,OAAO,cAAP,CAAsB,WAAtB,EAAmC,KAAnC,EAA0C;AACtC,gBAAY,KAD0B;AAEtC,WAAO,eAAS,IAAT,EAAe,KAAf,EAAsB;;AAEzB;AACA,YAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,oBAAQ,gBAAM,iBAAN,CAAwB,KAAxB,CAAR;AACH;;AAED;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,MAAM,MAA1B,EAAkC,GAAlC,EAAuC;AACnC,gBAAI,OAAO,MAAM,CAAN,CAAX;AACA,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,KAAK,MAAzB,EAAiC,GAAjC,EAAsC;AAClC,oBAAI,MAAM,KAAK,CAAL,CAAV;AACA,oBAAI,OAAO,GAAP,KAAe,QAAf,IAA2B,IAAI,CAAJ,MAAW,GAA1C,EAA+C;AAC3C,yBAAK,CAAL,IAAU,gBAAM,SAAN,CAAgB,GAAhB,CAAV;AACH;AACJ;AACJ;AACD,oBAAY,IAAZ,IAAoB,KAApB;AACH;AApBqC,CAA1C;;AAwBA;;;;;;;AAOA,OAAO,cAAP,CAAsB,WAAtB,EAAmC,WAAnC,EAAgD;AAC5C,gBAAY,KADgC;AAE5C,WAAO,eAAS,EAAT,EAAa;AAChB,eAAO,YAAY,EAAZ,KAAmB,IAA1B;AACH;AAJ2C,CAAhD;;AAOA;;;;;;AAMA,OAAO,cAAP,CAAsB,WAAtB,EAAmC,QAAnC,EAA6C;AACzC,gBAAY,KAD6B;AAEzC,WAAO,eAAS,EAAT,EAAa;AAChB,YAAI,QAAO,EAAP,yCAAO,EAAP,OAAc,QAAlB,EAA4B;AACxB,iBAAK,IAAI,IAAT,IAAiB,EAAjB,EAAqB;AACjB,4BAAY,MAAZ,CAAmB,IAAnB;AACH;AACD;AACH;AACD,YAAI,YAAY,EAAZ,CAAJ,EAAqB;AACjB,wBAAY,EAAZ,EAAgB,MAAhB,GAAyB,CAAzB;AACA,mBAAO,YAAY,EAAZ,CAAP;AACH;AACJ;AAbwC,CAA7C;;AAgBA;;;;;AAKA,OAAO,cAAP,CAAsB,WAAtB,EAAmC,WAAnC,EAAgD;AAC5C,gBAAY,KADgC;AAE5C,WAAO,iBAAW;AACd,aAAK,IAAI,EAAT,IAAe,WAAf,EAA4B;AACxB,wBAAY,MAAZ,CAAmB,EAAnB;AACH;AACJ;AAN2C,CAAhD;;AASA;kBACe;;;;;;;AC3Ff;;;;;;AAEA;;;;;;;AAOA,IAAI,eAAe,SAAf,YAAe,GAAW;AAC1B,WAAO,UAAS,QAAT,EAAmB,IAAnB,EAAyB;AAC5B,YAAI,MAAM,SAAS,GAAnB;AACA,YAAI,OAAO,SAAS,IAApB;;AAEA,YAAI,IAAI,MAAJ,CAAW,wBAAX,IAAuC,CAAC,CAA5C,EAA+C;AAC3C,kCAAY,GAAZ,CAAgB,SAAS,IAAzB,EAA+B,IAA/B;AACH,SAFD,MAEO,IAAI,KAAK,QAAL,IAAiB,KAAK,QAAL,KAAkB,KAAvC,EAA8C;AACjD;AACA;AACA,iBAAK,OAAL,CAAa,UAAb,CACI,KAAK,OAAL,CAAa,SAAb,CAAuB,GAAvB,CADJ,EAEI,SAAS,IAFb;AAIH;AACD;AACH,KAfD;AAgBH,CAjBD;;AAmBA;AACA,KAAK,OAAL,CAAa,MAAb,CAAoB,iBAApB,CAAsC,YAAtC;;kBAEe;;;;;;;AC/Bf;;;;;;AAEA;;;;;;;;AAQA,IAAM,WAAW,SAAX,QAAW,CAAS,MAAT,EAAiB;AAC9B,UAAM,IAAN,CAAW,IAAX;;AAEA;;;;;AAKA,SAAK,MAAL,GAAc,MAAd;;AAEA;;;;;;;AAOA,SAAK,aAAL,GAAqB,EAArB;AACH,CAlBD;;AAoBA,IAAM,IAAI,SAAS,SAAT,GAAqB,OAAO,MAAP,CAAc,MAAM,SAApB,CAA/B;;AAEA;;;;;;;AAOA,EAAE,QAAF,GAAa,UAAS,UAAT,EAAqB,UAArB,EAAiC,QAAjC,EAA2C,IAA3C,EAAiD;AAC1D,SAAK,eAAL,CAAqB,aAAa,CAAlC;AACA;AACA,QAAI,aAAa,EAAjB;AACA,QAAI,aAAJ;AACA;AACA,SAAK,IAAL,IAAa,UAAb,EAAyB;AACrB;AACA,YAAI,KAAK,aAAL,CAAmB,cAAnB,CAAkC,IAAlC,CAAJ,EAA6C;AACzC,uBAAW,IAAX,IAAmB,KAAK,aAAL,CAAmB,IAAnB,CAAnB;AACH;AACD;AAHA,aAIK;AACD,oBAAI,aAAa,WAAW,IAAX,IAAmB,KAAK,oBAAL,CAA0B,IAA1B,CAApC;AACA;AACA;AACA;AACA,qBAAK,IAAI,IAAI,KAAK,MAAL,GAAc,CAA3B,EAA8B,KAAK,CAAnC,EAAsC,EAAE,CAAxC,EAA2C;AACvC,yBAAK,CAAL,EAAQ,UAAR,CAAmB,IAAnB,IAA2B,UAA3B;AACA,yBAAK,CAAL,EAAQ,QAAR,CAAiB,IAAjB,IAAyB,UAAzB;AACH;AACJ;AACJ;AACD;AACA,QAAI,QAAQ,oBAAU,KAAK,MAAf,EAAuB,UAAvB,EAAmC,UAAnC,EAA+C,UAA/C,EAA2D,QAA3D,EAAqE,IAArE,CAAZ;AACA,SAAK,IAAL,CAAU,KAAV;AACA;AACA;AACA,WAAO,MAAP,CAAc,KAAK,aAAnB,EAAkC,MAAM,QAAxC;AACH,CA7BD;;AA+BA;;;;;;AAMA,EAAE,WAAF,GAAgB,UAAS,UAAT,EAAqB,UAArB,EAAiC;AAC7C,SAAK,eAAL,CAAqB,aAAa,CAAlC;AACA,QAAI,aAAa,OAAO,MAAP,CAAc,EAAd,EAAkB,KAAK,aAAvB,EAAsC,UAAtC,CAAjB;AACA;AACA,QAAI,QAAQ,oBAAU,KAAK,MAAf,EAAuB,UAAvB,EAAmC,IAAnC,EAAyC,UAAzC,EAAqD,CAArD,CAAZ;AACA,SAAK,IAAL,CAAU,KAAV;AACA,WAAO,MAAP,CAAc,KAAK,aAAnB,EAAkC,MAAM,QAAxC;AACH,CAPD;;AASA;;;;;AAKA,EAAE,eAAF,GAAoB,UAAS,QAAT,EAAmB;AACnC,QAAI,KAAK,MAAT,EAAiB;AACb,YAAI,YAAY,KAAK,KAAK,MAAL,GAAc,CAAnB,CAAhB;AACA,YAAI,UAAU,QAAV,GAAqB,QAAzB,EAAmC;AAC/B,gBAAI,UAAU,gBAAd,EAAgC;AAC5B,0BAAU,QAAV,GAAqB,QAArB;AACH,aAFD,MAEO;AACH,qBAAK,WAAL,CACI,KAAK,aADT,EAEI,UAAU,QAAV,GAAqB,CAFzB,EAGI,WAAW,UAAU,QAArB,GAAgC,CAHpC;AAKH;AACJ;AACJ;AACJ,CAfD;;AAiBA;;;;;AAKA,EAAE,oBAAF,GAAyB,UAAS,IAAT,EAAe;AACpC,QAAM,SAAS,KAAK,MAApB;AACA,YAAQ,IAAR;AACI,aAAK,GAAL;AACI,mBAAO,OAAO,QAAP,CAAgB,CAAvB;AACJ,aAAK,GAAL;AACI,mBAAO,OAAO,QAAP,CAAgB,CAAvB;AACJ,aAAK,IAAL;AACI,mBAAO,OAAO,KAAP,CAAa,CAApB;AACJ,aAAK,IAAL;AACI,mBAAO,OAAO,KAAP,CAAa,CAApB;AACJ,aAAK,IAAL;AACI,mBAAO,OAAO,IAAP,CAAY,CAAnB;AACJ,aAAK,IAAL;AACI,mBAAO,OAAO,IAAP,CAAY,CAAnB;AACJ,aAAK,GAAL;AACI,mBAAO,OAAO,QAAd;AACJ,aAAK,GAAL;AACI,mBAAO,OAAO,KAAd;AACJ,aAAK,GAAL;AACI,mBAAO,OAAO,OAAd;AACJ,aAAK,GAAL;AACI,mBAAO,OAAO,IAAd;AACA;AACA;AACA;AACA;AAxBR;AA0BA,WAAO,IAAP;AACH,CA7BD;;AA+BA;kBACe;;;;;;;;;AChJf;;;;;;;;;;;;IAYM;AAEF,mBAAY,MAAZ,EAAoB,UAApB,EAAgC,QAAhC,EAA0C,UAA1C,EAAsD,QAAtD,EAAgE,IAAhE,EAAsE;AAAA;;AAElE;;;;;AAKA,aAAK,MAAL,GAAc,MAAd;;AAEA;;;;;AAKA,aAAK,UAAL,GAAkB,UAAlB;;AAEA;;;;;;AAMA,aAAK,QAAL,GAAgB,EAAhB;;AAEA;;;;;AAKA,aAAK,QAAL,GAAgB,QAAhB;;AAEA;;;;;AAKA,aAAK,UAAL,GAAkB,UAAlB;;AAEA;;;;;AAKA,aAAK,QAAL,GAAgB,aAAa,QAA7B;;AAEA;;;;;AAKA,aAAK,IAAL,GAAY,IAAZ;;AAEA;;;;;AAKA,aAAK,gBAAL,GAAwB,CAAC,QAAzB;;AAGA,YAAI,aAAJ;AACA,YAAI,QAAJ,EAAc;AACV;AACA,iBAAK,IAAL,IAAa,QAAb,EAAuB;AACnB,qBAAK,QAAL,CAAc,IAAd,IAAsB,SAAS,IAAT,CAAtB;AACH;AACJ;;AAED;AACA,aAAK,IAAL,IAAa,UAAb,EAAyB;AACrB,gBAAI,CAAC,KAAK,QAAL,CAAc,cAAd,CAA6B,IAA7B,CAAL,EAAyC;AACrC,qBAAK,QAAL,CAAc,IAAd,IAAsB,WAAW,IAAX,CAAtB;AACH;AACJ;AACJ;;AAED;;;;;;;oBAKA,mCAAY,cAAc;AACtB;AACA;AACA,YAAI,gBAAgB,KAAK,QAAzB,EAAmC;AAC/B,iBAAK,QAAL;AACA;AACH;;AAED,YAAI,KAAK,gBAAT,EAA2B;AACvB,iBAAK,QAAL;AACA;AACH;;AAED,YAAI,OAAO,CAAC,eAAe,KAAK,UAArB,IAAmC,KAAK,QAAnD;AACA,YAAI,KAAK,IAAT,EAAe;AACX,mBAAO,KAAK,IAAL,CAAU,IAAV,CAAP;AACH;AACD,YAAI,SAAS,KAAK,MAAlB;AACA,YAAI,aAAa,KAAK,UAAtB;AACA,YAAI,WAAW,KAAK,QAApB;AACA,aAAK,IAAI,KAAT,IAAiB,QAAjB,EAA2B;AACvB,gBAAI,OAAO,MAAM,KAAN,CAAX;AACA,gBAAI,IAAJ,EAAU;AACN,qCAAqB,MAArB,EAA6B,KAA7B,EAAmC,KAAK,WAAW,KAAX,CAAL,EAAuB,SAAS,KAAT,CAAvB,EAAuC,IAAvC,CAAnC;AACH,aAFD,MAEO;AACH,qCAAqB,MAArB,EAA6B,KAA7B,EAAmC,WAAW,KAAX,CAAnC;AACH;AACJ;AACJ;;AAED;;;;;;oBAIA,+BAAW;AACP,YAAI,WAAW,KAAK,QAApB;AACA,YAAI,SAAS,KAAK,MAAlB;AACA,aAAK,IAAI,MAAT,IAAiB,QAAjB,EAA2B;AACvB,iCAAqB,MAArB,EAA6B,MAA7B,EAAmC,SAAS,MAAT,CAAnC;AACH;AACJ;;;;;AAGL;;;AACA,SAAS,SAAT,CAAmB,KAAnB,EAA0B,GAA1B,EAA+B,CAA/B,EAAkC;AAC9B,WAAO,QAAQ,CAAC,MAAM,KAAP,IAAgB,CAA/B;AACH;;AAED,IAAM,QAAQ;AACV;AACA,OAAG,SAFO;AAGV,OAAG,SAHO;AAIV;AACA,QAAI,SALM;AAMV,QAAI,SANM;AAOV;AACA,QAAI,SARM;AASV,QAAI,SATM;AAUV;AACA,OAAG,YAXO;AAYV;AACA,OAAG,SAbO;AAcV;AACA;AACA,OAAG,IAhBO;AAiBV;AACA,OAAG,IAlBO,EAkBD;AACT,OAAG,IAnBO,EAmBD;AACT,OAAG,IApBO,EAoBD;AACT,OAAG,IArBO,CAqBF;AArBE,CAAd;;AAwBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA,IAAM,KAAK,KAAK,EAAhB;AACA,IAAM,SAAS,KAAK,CAApB;;AAEA;AACA;AACA;AACA,SAAS,YAAT,CAAsB,KAAtB,EAA6B,GAA7B,EAAkC,CAAlC,EAAqC;AACjC,QAAI,aAAa,KAAK,GAAL,CAAS,MAAM,KAAf,CAAjB;AACA,QAAI,aAAa,EAAjB,EAAqB;AACjB;AACA,YAAI,MAAM,KAAV,EAAiB;AACb;AACA,qBAAS,MAAT;AACH,SAHD,MAGO;AACH;AACA,mBAAO,KAAK,MAAZ;AACH;AACJ;;AAED;AACA,QAAI,QAAS,QAAS,CAAC,MAAM,KAAP,IAAgB,CAAtC;;AAEA;AACA;;;;AAIA;AACA,WAAO,KAAP;AACH;;AAED,SAAS,oBAAT,CAA8B,MAA9B,EAAsC,IAAtC,EAA4C,KAA5C,EAAmD;AAC/C,YAAQ,IAAR;AACI,aAAK,GAAL;AACI,mBAAO,SAAP,CAAiB,QAAjB,CAA0B,CAA1B,GAA8B,KAA9B;AACA;AACJ,aAAK,GAAL;AACI,mBAAO,SAAP,CAAiB,QAAjB,CAA0B,CAA1B,GAA8B,KAA9B;AACA;AACJ,aAAK,IAAL;AACI,mBAAO,SAAP,CAAiB,KAAjB,CAAuB,CAAvB,GAA2B,KAA3B;AACA;AACJ,aAAK,IAAL;AACI,mBAAO,SAAP,CAAiB,KAAjB,CAAuB,CAAvB,GAA2B,KAA3B;AACA;AACJ,aAAK,IAAL;AACI,mBAAO,SAAP,CAAiB,IAAjB,CAAsB,CAAtB,GAA0B,KAA1B;AACA;AACJ,aAAK,IAAL;AACI,mBAAO,SAAP,CAAiB,IAAjB,CAAsB,CAAtB,GAA0B,KAA1B;AACA;AACJ,aAAK,GAAL;AACI,mBAAO,SAAP,CAAiB,QAAjB,GAA4B,KAA5B;AACA;AACJ,aAAK,GAAL;AACI,mBAAO,KAAP,GAAe,KAAf;AACA;AACJ,aAAK,GAAL;AACI,mBAAO,CAAP,CAAS,KAAT,EADJ,CACqB;AACjB;AACJ,aAAK,GAAL;AACI,mBAAO,CAAP,CAAS,KAAT,CAAe,MAAf,EAAuB,KAAvB,EADJ,CACmC;AAC/B;AACJ,aAAK,GAAL;AACI,mBAAO,OAAP,GAAiB,KAAjB;AACA;AACJ,aAAK,GAAL;AACI,mBAAO,EAAP,CAAU,KAAV,EADJ,CACsB;AAClB;AApCR;AAsCH;;AAED;kBACe;;;;;;;;ACrRf;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,IAAM,iBAAN;;AAEA;;;QAII;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,UAAA;;;;;;AC7BJ;;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;;;;;;;;;;;;;;AAoBA,IAAM,OAAO,SAAP,IAAO,CAAS,OAAT,EAAkB,MAAlB,EAA0B,QAA1B,EAAoC,QAApC,EAA8C;;AAEvD;AACA,QAAI,OAAO,MAAP,KAAkB,UAAtB,EAAkC;AAC9B,mBAAW,QAAX;AACA,mBAAW,MAAX;AACA,iBAAS,IAAT;AACH,KAJD,MAIO;AACH,YAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAC9B,uBAAW,QAAX;AACA,uBAAW,IAAX;AACH;AACJ;;AAED,QAAI,OAAO,OAAP,KAAmB,UAAvB,EAAmC;AAC/B,kBAAU;AACN,mBAAO,OADD;AAEN,oBAAQ,MAFF;AAGN,sBAAU,YAAY,EAHhB;AAIN,sBAAU;AAJJ,SAAV;AAMH;;AAED,cAAU,OAAO,MAAP,CAAc;AACpB,eAAO,IADa;AAEpB,gBAAQ,IAFY;AAGpB,kBAAU,EAHU;AAIpB,kBAAU;AAJU,KAAd,EAKP,WAAW,EALJ,CAAV;;AAOA,QAAM,SAAS,IAAI,KAAK,OAAL,CAAa,MAAjB,EAAf;;AAEA,aAAS,IAAT,GAAgB;AACZ,YAAI,WAAW,IAAI,QAAQ,KAAZ,EAAf;AACA,YAAI,QAAQ,MAAZ,EAAoB;AAChB,oBAAQ,MAAR,CAAe,QAAf,CAAwB,QAAxB;AACH;AACD,YAAI,QAAQ,QAAZ,EAAsB;AAClB,oBAAQ,QAAR,CAAiB,QAAjB,EAA2B,MAA3B;AACH;AACJ;;AAED;AACA,QAAI,SAAS,QAAQ,KAAR,CAAc,MAAd,IAAwB,EAArC;AACA,QAAI,UAAU,OAAO,IAAP,CAAY,MAAZ,EAAoB,MAAlC,EAA0C;AACtC;AACA,YAAI,YAAW,QAAQ,QAAvB;AACA,YAAI,SAAJ,EAAc;AACV,yBAAY,GAAZ;AACH;AACD,aAAK,IAAI,EAAT,IAAe,MAAf,EAAuB;AACnB,mBAAO,GAAP,CAAW,EAAX,EAAe,YAAW,OAAO,EAAP,CAA1B;AACH;AACD,eAAO,IAAP,CAAY,UAAZ,EAAwB,IAAxB,EAA8B,IAA9B;AACH,KAVD,MAUO;AACH;AACA;AACH;;AAED,WAAO,MAAP;AACH,CA5DD;;kBA8De;;;;;;ACnIf;;;;;;;;;;;;;kBAae,IAAI,KAAK,KAAL,CAAW,YAAf;;;;;;;;;ACbf;AACA,IAAI,WAAW,IAAf;;AAEA;;;;;IAIqB;;;;;AAEjB;;;;;iBAKO,+BAAU,KAAK;AAClB;AACA,cAAM,IAAI,MAAJ,CAAW,CAAX,CAAN;;AAEA;AACA,YAAI,IAAI,MAAJ,KAAe,CAAnB,EAAsB;AAClB,kBAAM,IAAI,OAAJ,CAAY,aAAZ,EAA2B,MAA3B,CAAN;AACH;AACD,eAAO,SAAS,GAAT,EAAc,EAAd,CAAP;AACH;;AAED;;;;;;;;;;iBAQO,iCAAW,UAAU,YAAY,UAAU;AAC9C;AACA,YAAM,YAAY,SAAS,MAA3B;AACA,YAAI,YAAY,aAAa,QAA7B,EAAuC;AACnC,qBAAS,MAAT,GAAkB,aAAa,QAA/B;AACA;AACA,gBAAI,YAAY,UAAhB,EAA4B;AACxB;AACA,oBAAI,SAAS,IAAb,EAAmB;AACf,6BAAS,IAAT,CAAc,KAAd,EAAqB,SAArB,EAAgC,UAAhC;AACH,iBAFD,MAEO;AACH;AACA,yBAAK,IAAI,IAAI,SAAb,EAAwB,IAAI,UAA5B,EAAwC,EAAE,CAA1C,EAA6C;AACzC,iCAAS,CAAT,IAAc,KAAd;AACH;AACJ;AACJ;AACJ;AACD;AACA,YAAI,SAAS,IAAb,EAAmB;AACf,qBAAS,IAAT,CAAc,IAAd,EAAoB,UAApB,EAAgC,aAAa,QAA7C;AACH,SAFD,MAEO;AACH,gBAAM,SAAS,SAAS,MAAxB;AACA;AACA,iBAAK,IAAI,KAAI,UAAb,EAAyB,KAAI,MAA7B,EAAqC,EAAE,EAAvC,EAA0C;AACtC,yBAAS,EAAT,IAAc,IAAd;AACH;AACJ;AACJ;;AAED;;;;;;;;;;iBAQO,qDAAqB,WAAW;AACnC,YAAI,SAAS,EAAb;AACA,YAAI,IAAI,CAAR;AACA,YAAI,UAAU;AACV,eAAG,GADO,EACF;AACR,eAAG,GAFO,EAEF;AACR,eAAG,IAHO,EAGD;AACT,eAAG,IAJO,EAID;AACT,eAAG,IALO,EAKD;AACT,eAAG,IANO,EAMD;AACT,eAAG,GAPO,EAOF;AACR,eAAG,GARO,EAQF;AACR,eAAG,GATO,EASF;AACR,eAAG,GAVO,EAUF;AACR,eAAG,GAXO,CAWH;AAXG,SAAd;AAaA,YAAI,UAAJ;AAAA,YACI,SAAS,EADb;AAAA,YAEI,iBAAiB,KAFrB;AAAA,YAGI,aAHJ;AAAA,YAII,QAAQ,EAJZ;;AAMA,eAAO,KAAK,UAAU,MAAtB,EAA8B;AAC1B,gBAAI,UAAU,CAAV,CAAJ;AACA,gBAAI,QAAQ,CAAR,CAAJ,EAAgB;AACZ,oBAAI,CAAC,cAAL,EAAqB;AACjB,qCAAiB,IAAjB;AACA,2BAAO,MAAP,IAAiB,KAAjB;AACH;AACD,oBAAI,IAAJ,EAAU;AACN,0BAAM,IAAN,IAAc,KAAK,UAAL,CAAgB,IAAhB,EAAsB,MAAtB,CAAd;AACH;AACD,uBAAO,QAAQ,CAAR,CAAP;AACA,yBAAS,EAAT;AACA;AACH;AACD;AAZA,iBAaK,IAAI,CAAC,CAAD,IAAM,MAAM,GAAhB,EAAqB;AACtB;AACA,0BAAM,IAAN,IAAc,KAAK,UAAL,CAAgB,IAAhB,EAAsB,MAAtB,CAAd;AACA,6BAAS,EAAT;AACA,2BAAO,IAAP;AACA,4BAAQ,EAAR;AACA,qCAAiB,KAAjB;AACH,iBAPI,MAOE;AACH,8BAAU,CAAV;AACA;AACH;AACJ;AACD,eAAO,MAAP;AACH;;AAED;;;;;;;;;iBAOO,+CAAkB,KAAK;AAC1B,YAAM,SAAS,EAAf;AACA;AACA,YAAI,SAAS,IAAI,KAAJ,CAAU,IAAV,CAAb;AACA,YAAI,YAAY,cAAhB;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,OAAO,MAA3B,EAAmC,GAAnC,EAAwC;AACpC,gBAAI,QAAQ,OAAO,CAAP,EAAU,KAAV,CAAgB,GAAhB,CAAZ,CADoC,CACF;AAClC,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,MAAM,MAA1B,EAAkC,GAAlC,EAAuC;AACnC;AACA,oBAAI,MAAM,MAAM,CAAN,CAAV;AACA,oBAAI,IAAI,CAAJ,MAAW,GAAX,IAAkB,CAAC,UAAU,IAAV,CAAe,GAAf,CAAvB,EAA4C;AACxC,0BAAM,CAAN,IAAW,WAAW,GAAX,CAAX;AACH;AACJ;AACD,mBAAO,IAAP,CAAY,KAAZ;AACH;AACD,eAAO,MAAP;AACH;;AAED;;;;;;;;;;;iBASO,iCAAW,MAAM,QAAQ;AAC5B,gBAAQ,IAAR;AACI;AACA,iBAAK,GAAL;AACI;AACI,6BAAS,OAAO,KAAP,CAAa,GAAb,CAAT;AACA,2BAAO,OAAP,CAAe,UAAS,GAAT,EAAc,CAAd,EAAiB,MAAjB,EAAyB;AACpC,+BAAO,CAAP,IAAY,WAAW,GAAX,CAAZ;AACH,qBAFD;AAGA,2BAAO,MAAP;AACH;AACD;AACA;AACJ,iBAAK,GAAL;AACI;AACI,2BAAO,MAAP;AACH;AACD;AACJ,iBAAK,GAAL;AACI;AACI,2BAAO,CAAC,CAAC,SAAS,MAAT,CAAT;AACH;AACD;AACJ;AACI;AACI,2BAAO,WAAW,MAAX,CAAP;AACH;AAzBT;AA2BH;;AAED;;;;;;;;;;iBAQO,yBAAO,UAAU,eAAe,MAAM;AACzC,YAAI,CAAC,QAAL,EAAe;AACX,uBAAW,SAAS,OAAT,CAAiB,OAA5B;AACA,qBAAS,QAAT,CAAkB,KAAK,aAAvB;AACH;AACD,iBAAS,MAAT,CAAgB,aAAhB,EAA+B,IAA/B;AACH;;AAED;;;;;;;;;iBAOO,uCAAc,MAAM;AACvB,YAAI,gBAAgB,KAAK,OAAL,CAAa,SAAjC,EAA4C;AACxC,iBAAK,oBAAL,CAA0B,OAA1B,CAAkC,UAAC,QAAD,EAAc;AAC5C,oBAAM,QAAQ,KAAK,QAAL,CAAc,OAAd,CAAsB,SAAS,MAA/B,CAAd;AACA,oBAAI,UAAU,CAAC,CAAf,EAAkB;AACd,6BAAS,GAAT,CAAa,SAAS,MAAtB;AACH;AACJ,aALD;AAMA,mBAAO,IAAP;AACH;AACD,eAAO,KAAP;AACH;;;;;kBAvNgB;;;;;ACPrB;;;;;AAKA,IAAM,IAAI,KAAK,SAAL,CAAe,SAAzB;;AAEA;;;;;;AAMA,EAAE,EAAF,GAAO,EAAE,QAAT;;AAEA;;;;;;;AAOA;;;;;;;AAOA,KAAK,SAAL,CAAe,MAAf,GAAwB,KAAK,SAAL,CAAe,CAAf,GAAmB,UAAS,KAAT,EAAgB;AACvD,QAAM,SAAN,GAAkB,OAAO,MAAP,CAAc,CAAd,CAAlB;AACA,QAAM,SAAN,CAAgB,QAAhB,GAA2B,CAA3B;AACA,QAAM,SAAN,CAAgB,WAAhB,GAA8B,KAA9B;AACA,SAAO,KAAP;AACH,CALD;;;;;AC7BA;;;;;;AAEA;;;;;AAKA,IAAM,IAAI,KAAK,aAAL,CAAmB,SAA7B;;AAEA;AACA,IAAI,0BAAJ;AACA,IAAI,KAAK,OAAT,EAAkB;AACd,sBAAoB,KAAK,OAAL,CAAa,iBAAjC;AACH;;AAED;;;;;;AAMA;;;;;;AAMA,EAAE,aAAF,GAAkB,EAAE,EAAF,GAAO,UAAS,UAAT,EAAqB;AAC1C,OAAK,UAAL,GAAkB,CAAC,CAAC,UAApB;AACA,SAAO,IAAP;AACH,CAHD;;AAKA;;;;;;;;;;;;;AAaA,EAAE,CAAF,GAAM,EAAE,YAAR;;AAEA;;;;;;AAMA;;;;;;AAMA,EAAE,OAAF,GAAY,EAAE,EAAF,GAAO,UAAS,IAAT,EAAe;AAC9B;AACA;AACA;AACA,MAAI,IAAJ,EAAU;AACN,QAAI,EAAE,gBAAgB,KAAK,QAAvB,KAAoC,EAAE,gBAAgB,KAAK,MAAvB,CAAxC,EAAwE;AACpE,UAAI,OAAO,OAAP,KAAmB,WAAnB,IAAkC,QAAQ,IAA9C,EAAoD;AAChD,gBAAQ,IAAR,CAAa,kEAAb;AACH;AACD,aAAO,IAAP;AACH;AACJ;AACD,OAAK,IAAL,GAAY,IAAZ;AACA,SAAO,IAAP;AACH,CAdD;;AAgBA;;;;;;AAMA;;;;;;AAMA,EAAE,QAAF,GAAa,EAAE,CAAF,GAAM,UAAS,KAAT,EAAgB;AAC/B,OAAK,KAAL,GAAa,KAAb;AACA,SAAO,IAAP;AACH,CAHD;;AAKA;;;;;;AAMA;;;;;;AAMA,EAAE,OAAF,GAAY,EAAE,CAAF,GAAM,UAAS,IAAT,EAAe;AAC7B,MAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC1B,WAAO,gBAAM,SAAN,CAAgB,IAAhB,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA,MAAI,IAAI,QAAQ,EAAR,GAAa,IAArB;AACA,MAAI,IAAI,QAAQ,CAAR,GAAY,IAApB;AACA,MAAI,IAAI,OAAO,IAAf;AACA,SAAO,KAAK,CAAL,CAAO,IAAI,GAAX,EAAgB,CAAhB,EAAmB,IAAI,GAAvB,EAA4B,CAA5B,EAA+B,IAAI,GAAnC,EAAwC,CAAxC,CAAP;AACH,CAdD;;AAgBA;;;;;;;;;;;AAWA;;;;;;;;;;;AAWA,EAAE,iBAAF,GAAsB,EAAE,CAAF,GAAM,UAAS,CAAT,EAAY,EAAZ,EAAgB,CAAhB,EAAmB,EAAnB,EAAuB,CAAvB,EAA0B,EAA1B,EAA8B;AACtD,MAAI,SAAS,KAAK,oBAAlB;AACA,SAAO,MAAP,CAAc,CAAd,IAAmB,CAAnB;AACA,SAAO,MAAP,CAAc,CAAd,IAAmB,EAAnB;AACA,SAAO,MAAP,CAAc,CAAd,IAAmB,CAAnB;AACA,SAAO,MAAP,CAAc,CAAd,IAAmB,EAAnB;AACA,SAAO,MAAP,CAAc,EAAd,IAAoB,CAApB;AACA,SAAO,MAAP,CAAc,EAAd,IAAoB,EAApB;AACA,OAAK,OAAL,GAAe,CAAC,MAAD,CAAf;AACA,SAAO,IAAP;AACH,CAVD;;AAYA;;;;AAIA,IAAI,CAAC,EAAE,cAAF,CAAiB,sBAAjB,CAAL,EAA+C;AAC3C,SAAO,cAAP,CAAsB,CAAtB,EAAyB,sBAAzB,EAAiD;AAC7C,SAAK,aAAS,MAAT,EAAiB;AAClB,WAAK,qBAAL,GAA6B,MAA7B;AACH,KAH4C;AAI7C,SAAK,eAAW;AACZ,aAAO,KAAK,qBAAL,IAA8B,IAAI,iBAAJ,EAArC;AACH;AAN4C,GAAjD;AAQH;;AAED;;;;;;;AAOA;;;;;;;AAOA,KAAK,aAAL,CAAmB,MAAnB,GAA4B,KAAK,aAAL,CAAmB,CAAnB,GAAuB,UAAS,KAAT,EAAgB;AAC/D,QAAM,SAAN,GAAkB,OAAO,MAAP,CAAc,CAAd,CAAlB;AACA,QAAM,SAAN,CAAgB,QAAhB,GAA2B,CAA3B;AACA,QAAM,SAAN,CAAgB,WAAhB,GAA8B,KAA9B;AACA,SAAO,KAAP;AACH,CALD;;;;;ACvLA;;;;;AAKA,IAAM,IAAI,KAAK,QAAL,CAAc,SAAxB;;AAEA;;;;;;AAMA;;;;;;;AAOA,EAAE,YAAF,GAAiB,EAAE,CAAF,GAAM,UAAS,QAAT,EAAmB;AACtC,MAAI,cAAJ;AAAA,MAAoB,SAAS,EAA7B;AAAA,MACI,IAAI,CADR;;AAGA,SAAO,KAAK,SAAS,MAArB,EAA6B;AACzB,QAAI,OAAO,SAAS,GAAT,CAAX;AACA,QAAI,SAAS,SAAT,IAAsB,KAAK,IAAL,CAA1B,EAAsC;AAClC,UAAI,cAAJ,EAAoB;AAChB,aAAK,cAAL,EAAqB,KAArB,CAA2B,IAA3B,EAAiC,MAAjC;AACA,eAAO,MAAP,GAAgB,CAAhB;AACH;AACD,uBAAiB,IAAjB;AACH,KAND,MAMO;AACH,aAAO,IAAP,CAAY,IAAZ;AACH;AACJ;AACD,SAAO,IAAP;AACH,CAjBD;;AAmBA;;;;;;AAMA,EAAE,CAAF,GAAM,EAAE,SAAR;;AAEA;;;;;AAKA,EAAE,CAAF,GAAM,EAAE,OAAR;;AAEA;;;;;;;AAOA,EAAE,CAAF,GAAM,EAAE,MAAR;;AAEA;;;;;;;AAOA,EAAE,CAAF,GAAM,EAAE,MAAR;;AAEA;;;;;;;;;;;AAWA,EAAE,CAAF,GAAM,EAAE,gBAAR;;AAEA;;;;;;;;;;;AAWA,EAAE,CAAF,GAAM,EAAE,aAAR;;AAEA;;;;;;;;AAQA,EAAE,CAAF,GAAM,EAAE,SAAR;;AAEA;;;;;;;;;AASA,EAAE,CAAF,GAAM,EAAE,SAAR;;AAEA;;;;;;;;;AASA;;;;;;;;;AASA,EAAE,EAAF,GAAO,EAAE,QAAT;;AAEA;;;;;;;;;;AAUA,EAAE,EAAF,GAAO,EAAE,eAAT;;AAEA;;;;;;;;;;;;;AAaA,EAAE,EAAF,GAAO,EAAE,eAAT;;AAEA;;;;;;;;AAQA,EAAE,EAAF,GAAO,EAAE,UAAT;;AAEA;;;;;;;;;;;AAWA,EAAE,EAAF,GAAO,EAAE,GAAT;;AAEA;;;;;;;;;;AAUA,EAAE,EAAF,GAAO,EAAE,KAAT;;AAEA;;;;;;;;AAQA,EAAE,EAAF,GAAO,EAAE,WAAT;;AAEA;;;;;;;AAOA,EAAE,EAAF,GAAO,UAAS,UAAT,EAAqB;AACxB;AACA,UAAQ,IAAR,CAAa,yCAAb;AACA;AACA,SAAO,KAAK,CAAL,CAAO,WAAW,CAAX,CAAP,CAAP;AACH,CALD;;AAOA;;;;;;;AAOA,EAAE,EAAF,GAAO,UAAS,UAAT,EAAqB;AACxB;AACA,UAAQ,IAAR,CAAa,yCAAb;AACA;AACA,SAAO,KAAK,CAAL,CAAO,WAAW,CAAX,CAAP,CAAP;AACH,CALD;;AAOA;;;;;AAKA,EAAE,EAAF,GAAO,YAAW;AACd;AACA,UAAQ,IAAR,CAAa,gCAAb;AACA;AACA,SAAO,KAAK,CAAL,CAAO,GAAP,CAAP;AACH,CALD;;AAOA;;;;;AAKA,EAAE,EAAF,GAAO,YAAW;AACd;AACA,UAAQ,IAAR,CAAa,kCAAb;AACA;AACA,SAAO,IAAP;AACH,CALD;;AAOA;;;;;AAKA,EAAE,EAAF,GAAO,YAAW;AACd;AACA,UAAQ,IAAR,CAAa,kCAAb;AACA;AACA,SAAO,IAAP;AACH,CALD;;AAOA;;;;;AAKA,EAAE,EAAF,GAAO,YAAW;AACd;AACA,UAAQ,IAAR,CAAa,2CAAb;AACA;AACA,SAAO,IAAP;AACH,CALD;;AAOA;;;;;AAKA,EAAE,EAAF,GAAO,YAAW;AACd;AACA,UAAQ,IAAR,CAAa,2CAAb;AACA;AACA,SAAO,IAAP;AACH,CALD;;;;;ACpSA;;;;;AAKA,IAAM,IAAI,KAAK,MAAL,CAAY,SAAtB;;AAEA;;;;;;;AAOA;;;;;;;AAOA,KAAK,MAAL,CAAY,MAAZ,GAAqB,KAAK,MAAL,CAAY,CAAZ,GAAgB,UAAS,KAAT,EAAgB;AACjD,QAAM,SAAN,GAAkB,OAAO,MAAP,CAAc,CAAd,CAAlB;AACA,QAAM,SAAN,CAAgB,QAAhB,GAA2B,CAA3B;AACA,QAAM,SAAN,CAAgB,WAAhB,GAA8B,KAA9B;AACA,SAAO,KAAP;AACH,CALD;;;;;ACrBA;;;;;AAKA,IAAM,IAAI,KAAK,IAAL,CAAU,SAApB;;AAEA;AACA,IAAM,eAAe,CAAC,QAAD,EAAW,OAAX,CAArB;;AAEA;;;;;;;AAOA;;;;;;AAMA,EAAE,QAAF,GAAa,EAAE,CAAF,GAAM,UAAS,KAAT,EAAgB;AAC/B,QAAI,OAAO,KAAP,IAAgB,QAApB,EAA8B;AAC1B,gBAAQ,aAAa,OAAb,CAAqB,KAArB,CAAR;AACH;AACD,SAAK,KAAL,CAAW,KAAX,GAAmB,aAAa,KAAb,KAAuB,MAA1C;AACA,SAAK,MAAL,CAAY,CAAZ,GAAgB,CAAC,QAAQ,CAAT,IAAc,CAA9B;AACA,WAAO,IAAP;AACH,CAPD;;AASA;AACA,IAAI,cAAc;AACd,OAAG,MADW,EACH;AACX,OAAG,UAFW;AAGd,OAAG,YAHW;AAId,OAAG,WAJW;AAKd,OAAG,YALW;AAMd,OAAG,MANW;AAOd,OAAG,OAPW;AAQd,OAAG,QARW;AASd,OAAG,iBATW;AAUd,OAAG,UAVW;AAWd,OAAG,eAXW;AAYd,OAAG,YAZW;AAad,OAAG,YAbW;AAcd,OAAG,iBAdW;AAed,OAAG,iBAfW;AAgBd,OAAG,gBAhBW;AAiBd,OAAG,SAjBW;AAkBd,OAAG,cAlBW;AAmBd,OAAG,UAnBW;AAoBd,OAAG,YApBW;AAqBd,OAAG;AArBW,CAAlB;;AAwBA;;;;;;AAMA;;;;;;AAMA,EAAE,QAAF,GAAa,EAAE,EAAF,GAAO,UAAS,KAAT,EAAgB;AAChC;AACA,SAAK,IAAI,CAAT,IAAc,WAAd,EAA2B;AACvB,YAAI,MAAM,CAAN,MAAa,SAAjB,EAA4B;AACxB,kBAAM,YAAY,CAAZ,CAAN,IAAwB,MAAM,CAAN,CAAxB;AACA,mBAAO,MAAM,CAAN,CAAP;AACH;AACJ;AACD,SAAK,KAAL,GAAa,KAAb;AACA,WAAO,IAAP;AACH,CAVD;;AAYA;;;;;;;;AAQA;;;;;;;;AAQA,EAAE,SAAF,GAAc,EAAE,EAAF,GAAO,UAAS,KAAT,EAAgB,KAAhB,EAAuB,QAAvB,EAAiC;AAClD,QAAI,QAAQ,KAAK,KAAjB;AACA,UAAM,UAAN,GAAmB,IAAnB;;AAEA;AACA,QAAI,UAAU,SAAd,EAAyB;AACrB,gBAAQ,MAAM,MAAM,QAAN,CAAe,EAAf,CAAd;AACH;AACD,UAAM,eAAN,GAAwB,cAAc,KAAd,EAAqB,MAAM,eAA3B,CAAxB;AACA,UAAM,eAAN,GAAwB,cAAc,KAAd,EAAqB,MAAM,eAA3B,CAAxB;AACA,UAAM,kBAAN,GAA2B,cAAc,QAAd,EAAwB,MAAM,kBAA9B,CAA3B;AACA,WAAO,IAAP;AACH,CAZD;;AAcA;;;;;;;;AAQA,IAAI,gBAAgB,SAAhB,aAAgB,CAAS,KAAT,EAAgB,YAAhB,EAA8B;AAC9C,WAAO,UAAU,SAAV,GAAsB,YAAtB,GAAqC,KAA5C;AACH,CAFD;;;;;;;ACvHA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA;;;kBAGe;AACX,kCADW;AAEX,0CAFW;AAGX,4BAHW;AAIX,gCAJW;AAKX;AALW;;;;;ACTf;AACA,IAAI,OAAO,IAAP,KAAgB,WAApB,EAAiC;AAC7B,UAAM,eAAN;AACH;;AAED,IAAI,CAAC,KAAK,OAAV,EAAmB;AACf;AACA,YAAQ,UAAR;;AAEA;AACA,WAAO,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;AACnC,oBAAY,IADuB;AAEnC,WAFmC,iBAE7B;AAAE,mBAAO,QAAQ,WAAR,CAAP;AAA8B;AAFH,KAAvC;AAIH;;AAED;AACA,IAAI,OAAO,MAAP,KAAkB,WAAlB,IAAiC,OAAO,OAA5C,EAAqD;AACjD,WAAO,OAAP,GAAiB,KAAK,OAAtB;AACH","file":"pixi-animate.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import AnimatorTimeline from './AnimatorTimeline';\r\n\r\n// Static collection of timelines\r\nconst timelines = [];\r\n\r\n/**\r\n * Play animation via start/stop frame labels\r\n * @class Animator\r\n * @memberof PIXI.animate\r\n */\r\nclass Animator {\r\n\r\n    /**\r\n     * The collection of timelines\r\n     * @name {Array<PIXI.animate.AnimatorTimeline>} PIXI.animate.Animator#_timelines\r\n     * @private\r\n     * @static\r\n     */\r\n    static get _timelines() {\r\n        return timelines;\r\n    }\r\n\r\n    /**\r\n     * Suffix added to label for a stop.\r\n     * @name {String} PIXI.animate.Animator.STOP_LABEL\r\n     * @static\r\n     * @default \"_stop\"\r\n     */\r\n    static get STOP_LABEL() {\r\n        return \"_stop\";\r\n    }\r\n\r\n    /**\r\n     * Suffix added to label for a loop.\r\n     * @name {String} PIXI.animate.Animator.LOOP_LABEL\r\n     * @static\r\n     * @default \"_loop\"\r\n     */\r\n    static get LOOP_LABEL() {\r\n        return \"_loop\";\r\n    }\r\n\r\n    /**\r\n     * Play an animation by frame labels. For instance, play animation sequence from\r\n     * \"idle\" to \"idle_stop\" or \"idle_loop\". If no event label is provided, will\r\n     * play the entire duration of the MovieClip.\r\n     * @method PIXI.animate.Animator#play\r\n     * @static\r\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\r\n     * @param {String|Function} [label] The frame label event to call, if no event is provided\r\n     *        will use the entire length of the MovieClip. Can also be the callback.\r\n     * @param {Function} [callback] Optional callback when complete\r\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\r\n     */\r\n    static play(instance, label, callback) {\r\n        let loop = false;\r\n        let start, end;\r\n        const labelIsFunction = typeof label === \"function\";\r\n        if (label === undefined || labelIsFunction) {\r\n            start = 0;\r\n            end = instance.totalFrames - 1;\r\n            if (labelIsFunction) {\r\n                callback = label;\r\n            }\r\n        } else {\r\n            start = instance.labelsMap[label];\r\n            end = instance.labelsMap[label + this.STOP_LABEL];\r\n            if (end === undefined) {\r\n                end = instance.labelsMap[label + this.LOOP_LABEL];\r\n                loop = true;\r\n            }\r\n            if (start === undefined) {\r\n                throw new Error(\"No start label matching '\" + label + \"'\");\r\n            } else if (end === undefined) {\r\n                throw new Error(\"No end label matching '\" + label + \"'\");\r\n            }\r\n        }\r\n        return this.fromTo(\r\n            instance,\r\n            start,\r\n            end,\r\n            loop,\r\n            callback\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Play an animation from the current frame to an end frame or label.\r\n     * @method PIXI.animate.Animator#to\r\n     * @static\r\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\r\n     * @param {String|Number} end The end frame or label.\r\n     * @param {Function} [callback] Optional callback when complete\r\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\r\n     */\r\n    static to(instance, end, callback) {\r\n        return this.fromTo(\r\n            instance,\r\n            instance.currentFrame,\r\n            end,\r\n            false,\r\n            callback\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Play a MovieClip from a start to end frame.\r\n     * @method PIXI.animate.Animator#fromTo\r\n     * @static\r\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\r\n     * @param {Number|String} start The starting frame index or label.\r\n     * @param {Number|String} end The ending frame index or label.\r\n     * @param {Boolean} [loop=false] If the animation should loop.\r\n     * @param {Function} [callback] Optional callback when complete\r\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\r\n     */\r\n    static fromTo(instance, start, end, loop, callback) {\r\n\r\n        if (typeof start === \"string\") {\r\n            const startLabel = start;\r\n            start = instance.labelsMap[startLabel];\r\n            if (start === undefined) {\r\n                throw new Error(\"No start label matching '\" + startLabel + \"'\");\r\n            }\r\n        }\r\n        if (typeof end === \"string\") {\r\n            const endLabel = end;\r\n            end = instance.labelsMap[endLabel];\r\n            if (end === undefined) {\r\n                throw new Error(\"No end label matching '\" + endLabel + \"'\");\r\n            }\r\n        }\r\n        if (start < 0) {\r\n            throw new Error('Start frame is out of bounds');\r\n        }\r\n        if (end >= instance.totalFrames) {\r\n            throw new Error('End frame is out of bounds');\r\n        }\r\n        if (start >= end) {\r\n            throw new Error('End frame is before start frame');\r\n        }\r\n\r\n        // Stop any animation that's playing\r\n        this.stop(instance);\r\n\r\n        loop = !!loop;\r\n\r\n        // Add a new timeline\r\n        const timeline = AnimatorTimeline.create(\r\n            instance,\r\n            start,\r\n            end,\r\n            loop,\r\n            callback\r\n        );\r\n        this._timelines.push(timeline);\r\n\r\n        // Set the current frame\r\n        if (instance.currentFrame !== start) {\r\n            instance.gotoAndPlay(start);\r\n        } else {\r\n            instance.play();\r\n        }\r\n        return timeline;\r\n    }\r\n\r\n    /**\r\n     * Stop the animation by instance.\r\n     * @method PIXI.animate.Animator#stop\r\n     * @static\r\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\r\n     */\r\n    static stop(instance) {\r\n        for (let i = 0, len = this._timelines.length; i < len; i++) {\r\n            const timeline = this._timelines[i];\r\n            if (timeline.instance === instance) {\r\n                this._internalStop(timeline);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop all the currently playing animations.\r\n     * @method PIXI.animate.Animator#stopAll\r\n     * @static\r\n     */\r\n    static stopAll() {\r\n        for (let i = this._timelines.length - 1; i >= 0; i--) {\r\n            this._internalStop(this._timelines[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop the animation\r\n     * @method PIXI.animate.Animator#_internalStop\r\n     * @private\r\n     * @static\r\n     * @param {PIXI.animate.AnimatorTimeline} timeline Timeline to stop.\r\n     */\r\n    static _internalStop(timeline) {\r\n        this._timelines.splice(this._timelines.indexOf(timeline), 1);\r\n        timeline.instance.stop();\r\n        timeline.destroy();\r\n    }\r\n}\r\n\r\nmodule.exports = Animator;","const pool = [];\r\n\r\n/**\r\n * Represents a single animation play.\r\n * @class AnimatorTimeline\r\n * @memberof PIXI.animate\r\n */\r\nclass AnimatorTimeline {\r\n    constructor() {\r\n        this._update = this.update.bind(this);\r\n        this.init(null, 0, 0, false, null);\r\n    }\r\n\r\n    /**\r\n     * The pool of timelines to use\r\n     * @method PIXI.animate.AnimatorTimeline#init\r\n     * @param {PIXI.animate.MovieClip} instance\r\n     * @param {Number} start\r\n     * @param {Number} end\r\n     * @param {Boolean} loop\r\n     * @param {Function} callback\r\n     * @private\r\n     */\r\n    init(instance, start, end, loop, callback) {\r\n\r\n        /**\r\n         * Instance of clip to play.\r\n         * @name PIXI.animate.AnimatorTimeline#instance\r\n         * @type {PIXI.animate.MovieClip}\r\n         * @readOnly\r\n         */\r\n        this.instance = instance;\r\n\r\n        /**\r\n         * `true` if the timeline is suppose to loop.\r\n         * @name PIXI.animate.AnimatorTimeline#loop\r\n         * @type {Boolean}\r\n         * @readOnly\r\n         */\r\n        this.loop = loop;\r\n\r\n        /**\r\n         * Frame number of the starting farme.\r\n         * @name PIXI.animate.AnimatorTimeline#start\r\n         * @type {int}\r\n         * @readOnly\r\n         */\r\n        this.start = start;\r\n\r\n        /**\r\n         * Frame number of the ending frame.\r\n         * @name PIXI.animate.AnimatorTimeline#end\r\n         * @type {int}\r\n         * @readOnly\r\n         */\r\n        this.end = end;\r\n\r\n        /**\r\n         * Callback called when completed (non-looping animation).\r\n         * @name PIXI.animate.AnimatorTimeline#callback\r\n         * @type {Function}\r\n         * @readOnly\r\n         */\r\n        this.callback = callback;\r\n\r\n        if (instance) {\r\n            instance.gotoAndStop(start);\r\n            instance._beforeUpdate = this._update;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Don't use after this\r\n     * @method PIXI.animate.AnimatorTimeline#destroy\r\n     * @private\r\n     */\r\n    destroy() {\r\n        this.instance._beforeUpdate = null;\r\n        this.init(null, 0, 0, false, null);\r\n        AnimatorTimeline._pool.push(this);\r\n    }\r\n\r\n    /**\r\n     * Is the animation complete\r\n     * @method PIXI.animate.AnimatorTimeline#update\r\n     * @param {PIXI.animate.MovieClip} instance\r\n     * @return {Function} Callback to do after updateTimeline\r\n     * @private\r\n     */\r\n    update(instance) {\r\n        let completed;\r\n        if (instance.currentFrame >= this.end) {\r\n\r\n            // In case we over-shoot the current frame becuase of low FPS\r\n            instance.currentFrame = this.end;\r\n\r\n            if (this.loop) {\r\n                // Update timeline so we get actions at the end frame\r\n                instance._updateTimeline();\r\n                instance.gotoAndPlay(this.start);\r\n            } else {\r\n                instance.stop();\r\n                if (this.callback) {\r\n                    completed = this.callback;\r\n                }\r\n                this.stop(); // cleanup timeline\r\n            }\r\n        }\r\n        return completed;\r\n    }\r\n\r\n    /**\r\n     * Stop the animation, cannot be reused.\r\n     * @method PIXI.animate.AnimatorTimeline#stop\r\n     */\r\n    stop() {\r\n        PIXI.animate.Animator._internalStop(this);\r\n    }\r\n\r\n    /**\r\n     * The progress from 0 to 1 of the playback.\r\n     * @name PIXI.animate.AnimatorTimeline#progress\r\n     * @type {Number}\r\n     * @readOnly\r\n     */\r\n    get progress() {\r\n        const progress = (this.instance.currentFrame - this.start) / (this.end - this.start);\r\n        return Math.max(0, Math.min(1, progress)); // clamp\r\n    }\r\n\r\n    /**\r\n     * The pool of timelines to use\r\n     * @name PIXI.animate.AnimatorTimeline._pool\r\n     * @type {Array<PIXI.animate.AnimatorTimeline>}\r\n     * @static\r\n     * @private\r\n     */\r\n    static get _pool() {\r\n        return pool;\r\n    }\r\n\r\n    /**\r\n     * Create a new timeline\r\n     * @method PIXI.animate.AnimatorTimeline.create\r\n     * @static\r\n     * @param {PIXI.animate.MovieClip} instance\r\n     * @param {Number} start\r\n     * @param {Number} end\r\n     * @param {Boolean} loop\r\n     * @param {Function} callback\r\n     * @return {PIXI.animate.AnimatorTimeline}\r\n     */\r\n    static create(instance, start, end, loop, callback) {\r\n        var timeline;\r\n        if (this._pool.length) {\r\n            timeline = this._pool.pop();\r\n        } else {\r\n            timeline = new AnimatorTimeline();\r\n        }\r\n        timeline.init(instance, start, end, loop, callback);\r\n        return timeline;\r\n    }\r\n}\r\n\r\nmodule.exports = AnimatorTimeline;","import Timeline from './Timeline';\r\nimport utils from './utils';\r\n\r\nconst Container = PIXI.Container;\r\nconst SharedTicker = PIXI.ticker.shared;\r\n\r\n/**\r\n * Provide timeline playback of movieclip\r\n * @memberof PIXI.animate\r\n * @class MovieClip\r\n * @extends PIXI.Container\r\n * @constructor\r\n * @param {Object|int} [options] The options object or the mode to play\r\n * @param {int} [options.mode=0] The playback mode default is independent (0),\r\n * @param {int} [options.startPosition=0] The starting frame\r\n * @param {Boolean} [options.loop=true] If playback is looped\r\n * @param {Object} [options.labels] The frame labels map of label to frames\r\n * @param {int} [options.duration] The duration, if no duration is provided, auto determines length\r\n * @param {int} [options.framerate=24] The framerate to use for independent mode\r\n */\r\nclass MovieClip extends Container {\r\n    constructor(options, duration, loop, framerate, labels) {\r\n        super();\r\n\r\n        // Default options\r\n        options = options === undefined ? {} : options;\r\n\r\n        // Options can also be the mode\r\n        if (typeof options === 'number') {\r\n            options = {\r\n                mode: options || MovieClip.INDEPENDENT,\r\n                duration: duration || 0,\r\n                loop: loop === undefined ? true : loop,\r\n                labels: labels || {},\r\n                framerate: framerate || 0,\r\n                startPosition: 0\r\n            };\r\n        } else {\r\n            // Apply defaults to options\r\n            options = Object.assign({\r\n                mode: MovieClip.INDEPENDENT,\r\n                startPosition: 0,\r\n                loop: true,\r\n                labels: {},\r\n                duration: 0,\r\n                framerate: 0\r\n            }, options);\r\n        }\r\n\r\n        /**\r\n         * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).\r\n         * See each constant for a description of the behaviour.\r\n         * @name PIXI.animate.MovieClip#mode\r\n         * @type int\r\n         * @default null\r\n         */\r\n        this.mode = options.mode;\r\n\r\n        /**\r\n         * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.\r\n         * @name PIXI.animate.MovieClip#startPosition\r\n         * @type Number\r\n         * @default 0\r\n         */\r\n        this.startPosition = options.startPosition;\r\n\r\n        /**\r\n         * Indicates whether this MovieClip should loop when it reaches the end of its timeline.\r\n         * @name PIXI.animate.MovieClip#loop\r\n         * @type Boolean\r\n         * @default true\r\n         */\r\n        this.loop = !!options.loop;\r\n\r\n        /**\r\n         * The current frame of the movieclip.\r\n         * @name PIXI.animate.MovieClip#currentFrame\r\n         * @type Number\r\n         * @default 0\r\n         * @readOnly\r\n         */\r\n        this.currentFrame = 0;\r\n\r\n        /**\r\n         * The collection of private labels\r\n         * @name PIXI.animate.MovieClip#_labels\r\n         * @type Array\r\n         * @private\r\n         */\r\n        this._labels = [];\r\n\r\n        /**\r\n         * The collection of private labels\r\n         * @name PIXI.animate.MovieClip#_labelDict\r\n         * @type Object\r\n         * @private\r\n         */\r\n        this._labelDict = options.labels;\r\n        if (options.labels) {\r\n            for (let name in options.labels) {\r\n                let label = {\r\n                    label: name,\r\n                    position: options.labels[name]\r\n                };\r\n                this._labels.push(label);\r\n            }\r\n            this._labels.sort(function(a, b) {\r\n                return a.position - b.position;\r\n            });\r\n        }\r\n\r\n        /**\r\n         * If true, this movieclip will animate automatically whenever it is on the stage.\r\n         * @name PIXI.animate.MovieClip#selfAdvance\r\n         * @type Boolean\r\n         * @default true\r\n         */\r\n        this.selfAdvance = true;\r\n\r\n        /**\r\n         * If true, the MovieClip's position will not advance when ticked.\r\n         * @name PIXI.animate.MovieClip#paused\r\n         * @type Boolean\r\n         * @default false\r\n         */\r\n        this.paused = false;\r\n\r\n        /**\r\n         * If true, actions in this MovieClip's tweens will be run when the playhead advances.\r\n         * @name PIXI.animate.MovieClip#actionsEnabled\r\n         * @type Boolean\r\n         * @default true\r\n         */\r\n        this.actionsEnabled = true;\r\n\r\n        /**\r\n         * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds\r\n         * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.\r\n         * <br><br>\r\n         * For example, if you had a character animation with a 'body' child MovieClip instance\r\n         * with different costumes on each frame, you could set body.autoReset = false, so that\r\n         * you can manually change the frame it is on, without worrying that it will be reset\r\n         * automatically.\r\n         * @name PIXI.animate.MovieClip#autoReset\r\n         * @type Boolean\r\n         * @default true\r\n         */\r\n        this.autoReset = true;\r\n\r\n        /**\r\n         * @name PIXI.animate.MovieClip#_synchOffset\r\n         * @type Number\r\n         * @default 0\r\n         * @private\r\n         */\r\n        this._synchOffset = 0;\r\n\r\n        /**\r\n         * @name PIXI.animate.MovieClip#_prevPos\r\n         * @type Number\r\n         * @default -1\r\n         * @private\r\n         */\r\n        this._prevPos = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.\r\n\r\n        /**\r\n         * Note - changed from default: When the MovieClip is framerate independent, this is the time\r\n         * elapsed from frame 0 in seconds.\r\n         * @name PIXI.animate.MovieClip#_t\r\n         * @type Number\r\n         * @default 0\r\n         * @private\r\n         */\r\n        this._t = 0;\r\n\r\n        /**\r\n         * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\r\n         * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\r\n         * framerate.\r\n         *\r\n         * @name PIXI.animate.MovieClip#_framerate\r\n         * @type {Number}\r\n         * @default 0\r\n         * @protected\r\n         */\r\n        this._framerate = options.framerate;\r\n\r\n        /**\r\n         * The total time in seconds for the animation. This is changed when setting the framerate.\r\n         * @name PIXI.animate.MovieClip#_duration\r\n         * @type Number\r\n         * @default 0\r\n         * @private\r\n         */\r\n        this._duration = 0;\r\n\r\n        /**\r\n         * The total duration in frames for the animation.\r\n         * @name PIXI.animate.MovieClip#_totalFrames\r\n         * @type Number\r\n         * @default 0\r\n         * @private\r\n         */\r\n        this._totalFrames = options.duration;\r\n\r\n        /**\r\n         * Standard tween timelines for all objects. Each element in the _timelines array\r\n         * is a Timeline object - an array of tweens for one target, in order of occurrence.\r\n         * @name PIXI.animate.MovieClip#_timelines\r\n         * @type Array\r\n         * @protected\r\n         */\r\n        this._timelines = [];\r\n\r\n        /**\r\n         * Array of child timelines denoting if a child is actively a child of this movieclip\r\n         * on any given frame. Each element in the _timedChildTimelines is an array with a 'target'\r\n         * property, and is an array of boolean values indexed by frame.\r\n         * @name PIXI.animate.MovieClip#_timedChildTimelines\r\n         * @type {Array}\r\n         * @protected\r\n         */\r\n        this._timedChildTimelines = [];\r\n\r\n        /**\r\n         * Array to depth sort timed children\r\n         * @name PIXI.animate.MovieClip#_depthSorted\r\n         * @type {Array}\r\n         * @private\r\n         */\r\n        this._depthSorted = [];\r\n\r\n        /**\r\n         * Array of frame scripts, indexed by frame.\r\n         * @name PIXI.animate.MovieClip#_actions\r\n         * @type {Array}\r\n         * @protected\r\n         */\r\n        this._actions = [];\r\n\r\n        /**\r\n         * Optional callback fired before timeline is updated.\r\n         * Can be used to clamp or update the currentFrame.\r\n         * @name PIXI.animate.MovieClip#_beforeUpdate\r\n         * @type {Function}\r\n         * @private\r\n         */\r\n        this._beforeUpdate = null;\r\n\r\n        if (this.mode === MovieClip.INDEPENDENT) {\r\n            this._tickListener = this._tickListener.bind(this);\r\n            this._onAdded = this._onAdded.bind(this);\r\n            this._onRemoved = this._onRemoved.bind(this);\r\n            this.on('added', this._onAdded);\r\n            this.on('removed', this._onRemoved);\r\n        }\r\n\r\n        if (options.framerate) {\r\n            this.framerate = options.framerate;\r\n        }\r\n\r\n        //save often used methods on the instance so that they can be fetched slightly faster\r\n        //than if they had to be fetched from the prototype\r\n        this.advance = this.advance;\r\n        this._updateTimeline = this._updateTimeline;\r\n        this._setTimelinePosition = this._setTimelinePosition;\r\n        this._goto = this._goto;\r\n    }\r\n\r\n    _onAdded() {\r\n        if (!this._framerate) {\r\n            this.framerate = this.parentFramerate;\r\n        }\r\n        SharedTicker.add(this._tickListener);\r\n    }\r\n\r\n    _tickListener(tickerDeltaTime) {\r\n        if (this.paused || !this.selfAdvance) {\r\n            //see if the movieclip needs to be updated even though it isn't animating\r\n            if (this._prevPos < 0) {\r\n                this._goto(this.currentFrame);\r\n            }\r\n            return;\r\n        }\r\n        let seconds = tickerDeltaTime / SharedTicker.speed / PIXI.settings.TARGET_FPMS / 1000;\r\n        this.advance(seconds);\r\n    }\r\n\r\n    _onRemoved() {\r\n        SharedTicker.remove(this._tickListener);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of objects with label and position (aka frame) properties, sorted by position.\r\n     * @name PIXI.animate.MovieClip#labels\r\n     * @type {Array}\r\n     * @readonly\r\n     */\r\n    get labels() {\r\n        return this._labels;\r\n    }\r\n\r\n    /**\r\n     * Returns a dictionary of labels where key is the label and value is the frame.\r\n     * @name PIXI.animate.MovieClip#labelsMap\r\n     * @type {Object}\r\n     * @readonly\r\n     */\r\n    get labelsMap() {\r\n        return this._labelDict;\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the label on or immediately before the current frame.\r\n     * @name PIXI.animate.MovieClip#currentLabel\r\n     * @type {String}\r\n     * @readonly\r\n     */\r\n    get currentLabel() {\r\n        let labels = this._labels;\r\n        let current = null;\r\n        for (let i = 0, len = labels.length; i < len; ++i) {\r\n            if (labels[i].position <= this.currentFrame) {\r\n                current = labels[i].label;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return current;\r\n    }\r\n\r\n    /**\r\n     * When the MovieClip is framerate independent, this is the time elapsed from frame 0 in seconds.\r\n     * @name PIXI.animate.MovieClip#elapsedTime\r\n     * @type Number\r\n     * @default 0\r\n     * @public\r\n     */\r\n    get elapsedTime() {\r\n        return this._t;\r\n    }\r\n\r\n    set elapsedTime(value) {\r\n        this._t = value;\r\n    }\r\n\r\n    /**\r\n     * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\r\n     * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\r\n     * framerate.\r\n     *\r\n     * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will\r\n     * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\r\n     * vary slightly between frames.\r\n     *\r\n     * This feature is dependent on the tick event object (or an object with an appropriate 'delta' property) being\r\n     * passed into {{#crossLink 'Stage/update'}}{{/crossLink}}.\r\n     * @name PIXI.animate.MovieClip#framerate\r\n     * @type {Number}\r\n     * @default 0\r\n     */\r\n    get framerate() {\r\n        return this._framerate;\r\n    }\r\n    set framerate(value) {\r\n        if (value > 0) {\r\n            this._framerate = value;\r\n            this._duration = value ? this._totalFrames / value : 0;\r\n            this._t = this.currentFrame / value;\r\n        } else {\r\n            this._t = this._framerate = this._duration = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the total number of frames (duration) of this MovieClip\r\n     * @name PIXI.animate.MovieClip#totalFrames\r\n     * @type {Number}\r\n     * @default 0\r\n     * @readOnly\r\n     */\r\n    get totalFrames() {\r\n        return this._totalFrames;\r\n    }\r\n\r\n    /**\r\n     * Extend the timeline to the last frame.\r\n     * @method PIXI.animate.MovieClip#_autoExtend\r\n     * @private\r\n     * @param {int} endFrame\r\n     */\r\n    _autoExtend(endFrame) {\r\n        if (this._totalFrames < endFrame) {\r\n            this._totalFrames = endFrame;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert values of properties\r\n     * @method PIXI.animate.MovieClip#_parseProperties\r\n     * @private\r\n     * @param {Object} properties\r\n     */\r\n    _parseProperties(properties) {\r\n        // Convert any string colors to uints\r\n        if (typeof properties.t === 'string') {\r\n            properties.t = utils.hexToUint(properties.t);\r\n        } else if (typeof properties.v === 'number') {\r\n            properties.v = !!properties.v;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a timeline for a child, synced timeline.\r\n     * @method PIXI.animate.MovieClip#_getChildTimeline\r\n     * @private\r\n     * @param {PIXI.animate.MovieClip} instance\r\n     * @return {PIXI.animate.Timeline}\r\n     */\r\n    _getChildTimeline(instance) {\r\n        for (let i = this._timelines.length - 1; i >= 0; --i) {\r\n            if (this._timelines[i].target === instance) {\r\n                return this._timelines[i];\r\n            }\r\n        }\r\n        let timeline = new Timeline(instance);\r\n        this._timelines.push(timeline);\r\n        return timeline;\r\n    }\r\n\r\n    /**\r\n     * Add mask or masks\r\n     * @method PIXI.animate.MovieClip#addTimedMask\r\n     * @param {PIXI.DisplayObject} instance Instance to mask\r\n     * @param {Object} keyframes The map of frames to mask objects\r\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\r\n     */\r\n    addTimedMask(instance, keyframes) {\r\n        for (let i in keyframes) {\r\n            this.addKeyframe(instance, {\r\n                m: keyframes[i]\r\n            }, parseInt(i, 10));\r\n        }\r\n\r\n        // Set the initial position/add\r\n        this._setTimelinePosition(this.currentFrame, this.currentFrame, true);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Shortcut alias for `addTimedMask`\r\n     * @method PIXI.animate.MovieClip#am\r\n     * @param {PIXI.DisplayObject} instance Instance to mask\r\n     * @param {Object} keyframes The map of frames to mask objects\r\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\r\n     */\r\n    am(instance, keyframes) {\r\n        return this.addTimedMask(instance, keyframes);\r\n    }\r\n\r\n    /**\r\n     * Add a tween to the clip\r\n     * @method PIXI.animate.MovieClip#addTween\r\n     * @param {PIXI.DisplayObject} instance The clip to tween\r\n     * @param {Object} properties The property or property to tween\r\n     * @param {int} startFrame The frame to start tweening\r\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\r\n     *                           with no tweening.\r\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    addTween(instance, properties, startFrame, duration, ease) {\r\n\r\n        let timeline = this._getChildTimeline(instance);\r\n        this._parseProperties(properties);\r\n        timeline.addTween(properties, startFrame, duration, ease);\r\n        this._autoExtend(startFrame + duration);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a tween to the clip\r\n     * @method PIXI.animate.MovieClip#addKeyframe\r\n     * @param {PIXI.DisplayObject} instance The clip to tween\r\n     * @param {Object} properties The property or property to tween\r\n     * @param {int} startFrame The frame to start tweening\r\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\r\n     *                           with no tweening.\r\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    addKeyframe(instance, properties, startFrame) {\r\n\r\n        let timeline = this._getChildTimeline(instance);\r\n        this._parseProperties(properties);\r\n        timeline.addKeyframe(properties, startFrame);\r\n        this._autoExtend(startFrame);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Alias for method `addTimedChild`\r\n     * @method PIXI.animate.MovieClip#at\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    at(instance, startFrame, duration, keyframes) {\r\n        return this.addTimedChild(instance, startFrame, duration, keyframes);\r\n    }\r\n\r\n    /**\r\n     * Add a child to show for a certain number of frames before automatic removal.\r\n     * @method PIXI.animate.MovieClip#addTimedChild\r\n     * @param {PIXI.DisplayObject} instance The clip to show\r\n     * @param {int} startFrame The starting frame\r\n     * @param {int} [duration=1] The number of frames to display the child before removing it.\r\n     * @param {String|Array} [keyframes] The collection of static keyframes to add\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    addTimedChild(instance, startFrame, duration, keyframes) {\r\n\r\n        if (startFrame === undefined) // jshint ignore:line\r\n        {\r\n            startFrame = 0;\r\n        }\r\n        if (duration === undefined || duration < 1) // jshint ignore:line\r\n        {\r\n            duration = this._totalFrames || 1;\r\n        }\r\n\r\n        // Add the starting offset for synced movie clips\r\n        if (instance.mode === MovieClip.SYNCHED) {\r\n            instance.parentStartPosition = startFrame;\r\n        }\r\n\r\n        //add tweening info about this child's presence on stage\r\n        //when the child is (re)added, if it has 'autoReset' set to true, then it\r\n        //should be set back to frame 0\r\n        let timeline, i;\r\n        //get existing timeline\r\n        for (i = this._timedChildTimelines.length - 1; i >= 0; --i) {\r\n            if (this._timedChildTimelines[i].target === instance) {\r\n                timeline = this._timedChildTimelines[i];\r\n                break;\r\n            }\r\n        }\r\n        //if there wasn't one, make a new one\r\n        if (!timeline) {\r\n            timeline = [];\r\n            timeline.target = instance;\r\n            this._timedChildTimelines.push(timeline);\r\n        }\r\n\r\n        // Fill the timeline with keyframe booleans\r\n        utils.fillFrames(timeline, startFrame, duration);\r\n\r\n        // Update the total frames if the instance extends our current\r\n        // total frames for this movieclip\r\n        if (this._totalFrames < startFrame + duration) {\r\n            this._totalFrames = startFrame + duration;\r\n        }\r\n\r\n        // Add the collection of keyframes\r\n        if (keyframes) {\r\n            if (typeof keyframes === \"string\") {\r\n                keyframes = utils.deserializeKeyframes(keyframes);\r\n            }\r\n            // Convert the keyframes object into\r\n            // individual properties\r\n            let lastFrame = {};\r\n            for (let i in keyframes) {\r\n                lastFrame = Object.assign({}, lastFrame, keyframes[i]);\r\n                this.addKeyframe(instance, lastFrame, parseInt(i, 10));\r\n            }\r\n            this._getChildTimeline(instance)\r\n                .extendLastFrame(startFrame + duration);\r\n        }\r\n\r\n        // Set the initial position/add\r\n        this._setTimelinePosition(startFrame, this.currentFrame, true);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Short cut for `addAction`\r\n     * @method PIXI.animate.MovieClip#aa\r\n     * @param {Function} callback The clip call on a certain frame\r\n     * @param {int|String} startFrame The starting frame index or label\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    aa(callback, startFrame) {\r\n        return this.addAction(callback, startFrame);\r\n    }\r\n\r\n    /**\r\n     * Handle frame actions, callback is bound to the instance of the MovieClip.\r\n     * @method PIXI.animate.MovieClip#addAction\r\n     * @param {Function} callback The clip call on a certain frame\r\n     * @param {int|String} startFrame The starting frame index or label\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    addAction(callback, startFrame) {\r\n\r\n        if (typeof startFrame === 'string') {\r\n            const index = this._labelDict[startFrame];\r\n            if (index === undefined) {\r\n                throw `The label '${startFrame}' does not exist on this timeline`;\r\n            }\r\n            startFrame = index;\r\n        }\r\n\r\n        let actions = this._actions;\r\n        //ensure that the movieclip timeline is long enough to support the target frame\r\n        if (actions.length <= startFrame) {\r\n            actions.length = startFrame + 1;\r\n        }\r\n        if (this._totalFrames < startFrame) {\r\n            this._totalFrames = startFrame;\r\n        }\r\n        //add the action\r\n        if (actions[startFrame]) {\r\n            actions[startFrame].push(callback);\r\n        } else {\r\n            actions[startFrame] = [callback];\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Short cut for `playSound`\r\n     * @method PIXI.animate.MovieClip#ps\r\n     * @param {String} alias The name of the Sound\r\n     * @param {Boolean} [loop=false] The loop property of the sound\r\n     * @param {MovieClip} context The MovieClip the sound originates from\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    ps(alias, loop) {\r\n        return this.playSound(alias, loop);\r\n    }\r\n\r\n    /**\r\n     * Handle sounds.\r\n     * @method PIXI.animate.MovieClip#playSound\r\n     * @param {String} alias The name of the Sound\r\n     * @param {Boolean} [loop=false] The loop property of the sound\r\n     * @param {MovieClip} context The MovieClip the sound originates from\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    playSound(alias, loop) {\r\n        PIXI.animate.sound.emit('play', alias, !!loop, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets paused to false.\r\n     * @method PIXI.animate.MovieClip#play\r\n     */\r\n    play() {\r\n        this.paused = false;\r\n    }\r\n\r\n    /**\r\n     * Sets paused to true.\r\n     * @method PIXI.animate.MovieClip#stop\r\n     */\r\n    stop() {\r\n        this.paused = true;\r\n    }\r\n\r\n    /**\r\n     * Advances this movie clip to the specified position or label and sets paused to false.\r\n     * @method PIXI.animate.MovieClip#gotoAndPlay\r\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\r\n     */\r\n    gotoAndPlay(positionOrLabel) {\r\n        this.paused = false;\r\n        this._goto(positionOrLabel);\r\n    }\r\n\r\n    /**\r\n     * Advances this movie clip to the specified position or label and sets paused to true.\r\n     * @method PIXI.animate.MovieClip#gotoAndStop\r\n     * @param {String|Number} positionOrLabel The animation or frame name to go to.\r\n     */\r\n    gotoAndStop(positionOrLabel) {\r\n        this.paused = true;\r\n        this._goto(positionOrLabel);\r\n    }\r\n\r\n    /**\r\n     * Get the close parent with a valid framerate. If no parent, returns the default framerate.\r\n     * @name PIXI.animate.MovieClip#parentFramerate\r\n     * @type {Number}\r\n     * @readOnly\r\n     */\r\n    get parentFramerate() {\r\n        let o = this,\r\n            fps = o._framerate;\r\n        while ((o = o.parent) && !fps) {\r\n            if (o.mode === MovieClip.INDEPENDENT) {\r\n                fps = o._framerate;\r\n            }\r\n        }\r\n        return fps || MovieClip.DEFAULT_FRAMERATE;\r\n    }\r\n\r\n    /**\r\n     * Advances the playhead. This occurs automatically each tick by default.\r\n     * @method PIXI.animate.MovieClip#advance\r\n     * @param [time] {Number} The amount of time in seconds to advance by. Only applicable if framerate is set.\r\n     */\r\n    advance(time) {\r\n\r\n        // Handle any other cases where starting to play\r\n        // and no framerate has been set yet\r\n        if (!this._framerate) {\r\n            this.framerate = this.parentFramerate;\r\n        }\r\n\r\n        if (time) {\r\n            this._t += time;\r\n        }\r\n        if (this._t > this._duration) {\r\n            this._t = this.loop ? this._t - this._duration : this._duration;\r\n        }\r\n        //add a tiny amount to account for potential floating point errors\r\n        this.currentFrame = Math.floor(this._t * this._framerate + 0.00000001);\r\n        //final error checking\r\n        if (this.currentFrame >= this._totalFrames) {\r\n            this.currentFrame = this._totalFrames - 1;\r\n        }\r\n        let afterUpdateOnce;\r\n        if (this._beforeUpdate) {\r\n            afterUpdateOnce = this._beforeUpdate(this);\r\n        }\r\n        //update all tweens & actions in the timeline\r\n        this._updateTimeline();\r\n\r\n        // Do the animator callback here\r\n        if (afterUpdateOnce) {\r\n            afterUpdateOnce();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method PIXI.animate.MovieClip#_goto\r\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\r\n     * @protected\r\n     */\r\n    _goto(positionOrLabel) {\r\n        let pos = typeof positionOrLabel === 'string' ? this._labelDict[positionOrLabel] : positionOrLabel;\r\n        if (pos === undefined) // jshint ignore:line\r\n        {\r\n            return;\r\n        }\r\n        // prevent _updateTimeline from overwriting the new position because of a reset:\r\n        this._prevPos = NaN;\r\n        this.currentFrame = pos;\r\n\r\n        // Handle the case where trying to play but haven't\r\n        // added to the stage yet\r\n        if (!this._framerate) {\r\n            this.framerate = this.parentFramerate;\r\n        }\r\n\r\n        //update the elapsed time if a time based movieclip\r\n        if (this._framerate > 0) {\r\n            this._t = pos / this._framerate;\r\n        } else {\r\n            this._t = 0;\r\n        }\r\n        this._updateTimeline();\r\n    }\r\n\r\n    /**\r\n     * @method PIXI.animate.MovieClip#_reset\r\n     * @private\r\n     */\r\n    _reset() {\r\n        this._prevPos = -1;\r\n        this._t = 0;\r\n        this.currentFrame = 0;\r\n    }\r\n\r\n    /**\r\n     * @method PIXI.animate.MovieClip#_updateTimeline\r\n     * @protected\r\n     */\r\n    _updateTimeline() {\r\n        let synched = this.mode !== MovieClip.INDEPENDENT;\r\n\r\n        if (synched) {\r\n            this.currentFrame = this.startPosition + (this.mode === MovieClip.SINGLE_FRAME ? 0 : this._synchOffset);\r\n            if (this.currentFrame >= this._totalFrames) {\r\n                this.currentFrame %= this._totalFrames;\r\n            }\r\n        }\r\n\r\n        if (this._prevPos === this.currentFrame) {\r\n            return;\r\n        }\r\n\r\n        // update timeline position, ignoring actions if this is a graphic.\r\n        this._setTimelinePosition(this._prevPos, this.currentFrame, synched ? false : this.actionsEnabled);\r\n\r\n        this._prevPos = this.currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Set the timeline position\r\n     * @method PIXI.animate.MovieClip#_setTimelinePosition\r\n     * @protected\r\n     * @param {int} startFrame\r\n     * @param {int} currentFrame\r\n     * @param {Boolean} doActions\r\n     */\r\n    _setTimelinePosition(startFrame, currentFrame, doActions) {\r\n        //handle all tweens\r\n        let i, j, length, _timelines = this._timelines;\r\n        for (i = _timelines.length - 1; i >= 0; --i) {\r\n            let timeline = _timelines[i];\r\n            for (j = 0, length = timeline.length; j < length; ++j) {\r\n                let tween = timeline[j];\r\n                //if the tween contains part of the timeline that we are travelling through\r\n                if (currentFrame >= tween.startFrame &&\r\n                    currentFrame <= tween.endFrame) {\r\n                    // set the position within that tween\r\n                    //and break the loop to move onto the next timeline\r\n                    tween.setPosition(currentFrame);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        let timedChildTimelines = this._timedChildTimelines;\r\n        let depthSorted = this._depthSorted;\r\n        for (i = 0, length = timedChildTimelines.length; i < length; ++i) {\r\n            let target = timedChildTimelines[i].target;\r\n            let shouldBeChild = timedChildTimelines[i][currentFrame];\r\n            //if child should be on stage and is not:\r\n            if (shouldBeChild) {\r\n                // Add to the depthSorted object so we can\r\n                // check that items are property drawn later\r\n                depthSorted.push(target);\r\n                if (target.parent !== this) {\r\n                    // add the target if it's not there already\r\n                    this.addChild(target);\r\n                    if (target.mode === MovieClip.INDEPENDENT && target.autoReset) {\r\n                        target._reset();\r\n                    }\r\n                }\r\n            } else if (!shouldBeChild && target.parent === this) {\r\n                this.removeChild(target);\r\n            }\r\n        }\r\n\r\n        // Properly depth sort the children\r\n        for (i = 0, length = depthSorted.length; i < length; i++) {\r\n            let target = depthSorted[i];\r\n            let currentIndex = this.children.indexOf(target);\r\n            if (currentIndex !== i) {\r\n                this.addChildAt(target, i);\r\n            }\r\n        }\r\n\r\n        // Clear the temporary depth sorting array\r\n        depthSorted.length = 0;\r\n\r\n        //go through all children and update synched movieclips that are not single frames\r\n        let children = this.children,\r\n            child;\r\n        for (i = 0, length = children.length; i < length; ++i) {\r\n            child = children[i];\r\n            if (child.mode === MovieClip.SYNCHED) {\r\n                child._synchOffset = currentFrame - child.parentStartPosition;\r\n                child._updateTimeline();\r\n            }\r\n        }\r\n\r\n        //handle actions\r\n        if (doActions) {\r\n            let actions = this._actions;\r\n            //handle looping around\r\n            let needsLoop = false;\r\n            if (currentFrame < startFrame) {\r\n                length = actions.length;\r\n                needsLoop = true;\r\n            } else {\r\n                length = Math.min(currentFrame + 1, actions.length);\r\n            }\r\n            for (i = startFrame >= 0 ? startFrame + 1 : currentFrame; i < length; ++i) {\r\n                if (actions[i]) {\r\n                    let frameActions = actions[i];\r\n                    for (j = 0; j < frameActions.length; ++j) {\r\n                        frameActions[j].call(this);\r\n                    }\r\n                }\r\n                //handle looping around\r\n                if (needsLoop && i === length - 1) {\r\n                    i = 0;\r\n                    length = currentFrame + 1;\r\n                    needsLoop = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    destroy(destroyChildren) {\r\n        if (this._tickListener) {\r\n            SharedTicker.remove(this._tickListener);\r\n            this._tickListener = null;\r\n        }\r\n        const hiddenChildren = [];\r\n        let timelines = this._timelines;\r\n        if (timelines) {\r\n            for (let i = 0; i < timelines.length; i++) {\r\n                const timeline = timelines[i];\r\n                hiddenChildren.push(timeline.target);\r\n                timeline._currentProps = null;\r\n                timeline.length = 0;\r\n            }\r\n        }\r\n        timelines = this._timedChildTimelines;\r\n        if (timelines) {\r\n            for (let i = 0; i < timelines.length; i++) {\r\n                const timeline = timelines[i];\r\n                if (hiddenChildren.indexOf(timeline.target) < 0) {\r\n                    hiddenChildren.push(timeline.target);\r\n                }\r\n                timeline._currentProps = null;\r\n                timeline.length = 0;\r\n            }\r\n        }\r\n        // Destroy all the children\r\n        for (let i = 0; i < hiddenChildren.length; i++) {\r\n            // Don't destroy children in the display list\r\n            if (this.children.indexOf(hiddenChildren[i]) < 0) {\r\n                hiddenChildren[i].destroy(destroyChildren);\r\n            }\r\n        }\r\n        hiddenChildren.length = 0;\r\n        this._actions = null;\r\n        this._timelines = null;\r\n        this._depthSorted = null;\r\n        this._timedChildTimelines = null;\r\n        this._beforeUpdate = null;\r\n        this._labels = null;\r\n        this._labelDict = null;\r\n        super.destroy(destroyChildren);\r\n    }\r\n}\r\n\r\n/**\r\n * The MovieClip will advance independently of its parent, even if its parent is paused.\r\n * This is the default mode.\r\n * @name PIXI.animate.MovieClip.INDEPENDENT\r\n * @static\r\n * @type String\r\n * @default 0\r\n * @readonly\r\n */\r\nMovieClip.INDEPENDENT = 0;\r\n\r\n/**\r\n * The MovieClip will only display a single frame (as determined by the startPosition property).\r\n * @name PIXI.animate.MovieClip.SINGLE_FRAME\r\n * @static\r\n * @type String\r\n * @default 1\r\n * @readonly\r\n */\r\nMovieClip.SINGLE_FRAME = 1;\r\n\r\n/**\r\n * The MovieClip will be advanced only when its parent advances and will be synched to the position of\r\n * the parent MovieClip.\r\n * @name PIXI.animate.MovieClip.SYNCHED\r\n * @static\r\n * @type String\r\n * @default 2\r\n * @readonly\r\n */\r\nMovieClip.SYNCHED = 2;\r\n\r\n\r\n/**\r\n * The default framerate if none is specified or there's not parent clip with a framerate.\r\n * @name PIXI.animate.MovieClip.DEFAULT_FRAMERATE\r\n * @static\r\n * @type Number\r\n * @default 24\r\n * @readonly\r\n */\r\nMovieClip.DEFAULT_FRAMERATE = 24;\r\n\r\n/**\r\n * Extend a container\r\n * @method PIXI.animate.MovieClip.extend\r\n * @static\r\n * @param {PIXI.animate.MovieClip} child The child function\r\n * @return {PIXI.animate.MovieClip} The child\r\n */\r\n/**\r\n * Extend a container (alias for `extend`)\r\n * @method PIXI.animate.MovieClip.e\r\n * @static\r\n * @param {PIXI.animate.MovieClip} child The child function\r\n * @return {PIXI.animate.MovieClip} The child\r\n */\r\nMovieClip.extend = MovieClip.e = function(child) {\r\n    child.prototype = Object.create(MovieClip.prototype);\r\n    child.prototype.__parent = MovieClip.prototype;\r\n    child.prototype.constructor = child;\r\n    return child;\r\n};\r\n\r\n// Assign to namespace\r\nexport default MovieClip;","import load from './load';\r\nimport sound from './sound';\r\n\r\n/**\r\n * Extends the PIXI.Application class to provide easy loading.\r\n * ```\r\n * const scene = new PIXI.animate.Scene();\r\n * scene.load(lib.StageName);\r\n * ```\r\n * @class Scene\r\n * @memberof PIXI.animate\r\n * @param {Number} [width=800] Stage width\r\n * @param {Number} [height=600] Stage height\r\n * @param {Object} [renderOptions] See PIXI.Application for more info.\r\n * @param {Boolean} [noWebGL=false] Disable WebGL\r\n */\r\nclass Scene extends PIXI.Application {\r\n\r\n\tconstructor(width, height, renderOptions, noWebGL) {\r\n\t\tsuper(width, height, renderOptions, noWebGL);\r\n\r\n\t\t/**\r\n\t\t * Reference to the global sound object\r\n\t\t * @name PIXI.animate.Scene#sound\r\n\t\t * @type {PIXI.animate.sound}\r\n\t\t * @readOnly\r\n\t\t */\r\n\t\tthis.sound = sound;\r\n\r\n\t\t/**\r\n\t\t * The stage object created.\r\n\t\t * @name PIXI.animate.Scene#instance\r\n\t\t * @type {PIXI.animate.MovieClip}\r\n\t\t * @readOnly\r\n\t\t */\r\n\t\tthis.instance = null;\r\n\t}\r\n\r\n\t/**\r\n\t * Load a stage scene and add it to the stage.\r\n\t * @method PIXI.animate.Scene#load\r\n\t * @param {Function} StageRef Reference to the stage class.\r\n\t * @param {Function} [complete] Callback when finished loading.\r\n\t * @param {String} [basePath] Optional base directory to prepend to assets.\r\n\t * @return {PIXI.loaders.Loader} instance of PIXI resource loader\r\n\t */\r\n\tload(StageRef, complete, basePath) {\r\n\t\treturn load(StageRef, this.stage, (instance) => {\r\n\t\t\tthis.instance = instance;\r\n\t\t\tif (complete) {\r\n\t\t\t\tcomplete(instance);\r\n\t\t\t}\r\n\t\t}, basePath);\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy and don't use after calling.\r\n\t * @method PIXI.animate.Scene#destroy\r\n\t * @param {Boolean} [removeView=false] `true` to remove canvas element.\r\n\t */\r\n\tdestroy(removeView) {\r\n\t\tif (this.instance) {\r\n\t\t\tthis.instance.destroy(true);\r\n\t\t\tthis.instance = null;\r\n\t\t}\r\n\t\tsuper.destroy(removeView);\r\n\t}\r\n}\r\n\r\nexport default Scene;","import utils from './utils';\r\n\r\n/**\r\n * Contains the collection of graphics data\r\n * @memberof PIXI.animate\r\n * @class ShapesCache\r\n */\r\nconst ShapesCache = {};\r\n\r\n/**\r\n * Add an item or itesm to the cache\r\n * @method PIXI.animate.ShapesCache.add\r\n * @static\r\n * @param {String} prop  The id of graphic or the map of graphics to add\r\n * @param {String|Array<Array>} items Collection of draw commands\r\n */\r\nObject.defineProperty(ShapesCache, 'add', {\r\n    enumerable: false,\r\n    value: function(prop, items) {\r\n\r\n        // Decode string to map of files\r\n        if (typeof items === \"string\") {\r\n            items = utils.deserializeShapes(items);\r\n        }\r\n\r\n        // Convert all hex string colors (animate) to int (pixi.js)\r\n        for (let i = 0; i < items.length; i++) {\r\n            let item = items[i];\r\n            for (let j = 0; j < item.length; j++) {\r\n                let arg = item[j];\r\n                if (typeof arg === 'string' && arg[0] === '#') {\r\n                    item[j] = utils.hexToUint(arg);\r\n                }\r\n            }\r\n        }\r\n        ShapesCache[prop] = items;\r\n    }\r\n});\r\n\r\n\r\n/**\r\n * Get the graphic from cache\r\n * @method  PIXI.animate.ShapesCache.fromCache\r\n * @static\r\n * @param  {String} id The cache id\r\n * @return {Array} Series of graphic draw commands\r\n */\r\nObject.defineProperty(ShapesCache, 'fromCache', {\r\n    enumerable: false,\r\n    value: function(id) {\r\n        return ShapesCache[id] || null;\r\n    }\r\n});\r\n\r\n/**\r\n * Remove the graphic from cache\r\n * @method  PIXI.animate.ShapesCache.remove\r\n * @static\r\n * @param  {String|Object} id The cache id or map\r\n */\r\nObject.defineProperty(ShapesCache, 'remove', {\r\n    enumerable: false,\r\n    value: function(id) {\r\n        if (typeof id === \"object\") {\r\n            for (let name in id) {\r\n                ShapesCache.remove(name);\r\n            }\r\n            return;\r\n        }\r\n        if (ShapesCache[id]) {\r\n            ShapesCache[id].length = 0;\r\n            delete ShapesCache[id];\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Remove all graphics from cache\r\n * @method  PIXI.animate.ShapesCache.removeAll\r\n * @static\r\n */\r\nObject.defineProperty(ShapesCache, 'removeAll', {\r\n    enumerable: false,\r\n    value: function() {\r\n        for (let id in ShapesCache) {\r\n            ShapesCache.remove(id);\r\n        }\r\n    }\r\n});\r\n\r\n// Assign to namespace\r\nexport default ShapesCache;","import ShapesCache from './ShapesCache';\r\n\r\n/**\r\n * The middleware for PIXI's ResourceLoader to be able to \r\n * load Flash symbols such as graphics and images.\r\n * @memberof PIXI.animate\r\n * @class SymbolLoader\r\n * @private\r\n */\r\nlet SymbolLoader = function() {\r\n    return function(resource, next) {\r\n        let url = resource.url;\r\n        let data = resource.data;\r\n\r\n        if (url.search(/\\.shapes\\.(json|txt)$/i) > -1) {\r\n            ShapesCache.add(resource.name, data);\r\n        } else if (data.nodeName && data.nodeName === 'IMG') {\r\n            // Add individual images to the texture cache by their\r\n            // short symbol name, not the URL\r\n            PIXI.Texture.addToCache(\r\n                PIXI.Texture.fromFrame(url),\r\n                resource.name\r\n            );\r\n        }\r\n        next();\r\n    };\r\n};\r\n\r\n// Assign to the loader\r\nPIXI.loaders.Loader.addPixiMiddleware(SymbolLoader);\r\n\r\nexport default SymbolLoader;","import Tween from './Tween';\r\n\r\n/**\r\n * The Timeline class represents a\r\n * @memberof PIXI.animate\r\n * @class Timeline\r\n * @param {PIXI.DisplayObject} Target The target for this string of tweens.\r\n * @extends Array\r\n * @constructor\r\n */\r\nconst Timeline = function(target) {\r\n    Array.call(this);\r\n\r\n    /**\r\n     * The target DisplayObject.\r\n     * @name PIXI.animate.Timeline#target\r\n     * @type {PIXI.DisplayObject}\r\n     */\r\n    this.target = target;\r\n\r\n    /**\r\n     * Current properties in the tween, to make building the timeline more\r\n     * efficient.\r\n     * @name PIXI.animate.Timeline#_currentProps\r\n     * @type {Object}\r\n     * @private\r\n     */\r\n    this._currentProps = {};\r\n};\r\n\r\nconst p = Timeline.prototype = Object.create(Array.prototype);\r\n\r\n/**\r\n * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the normal ticking system)\r\n * and managed by this timeline. Adding a tween to multiple timelines will result in unexpected behaviour.\r\n * @method PIXI.animate.Timeline#addTween\r\n * @param tween The tween(s) to add. Accepts multiple arguments.\r\n * @return Tween The first tween that was passed in.\r\n */\r\np.addTween = function(properties, startFrame, duration, ease) {\r\n    this.extendLastFrame(startFrame - 1);\r\n    //ownership of startProps is passed to the new Tween - this object should not be reused\r\n    let startProps = {};\r\n    let prop;\r\n    //figure out what the starting values for this tween should be\r\n    for (prop in properties) {\r\n        //if we have already set that property in an earlier tween, use the ending value\r\n        if (this._currentProps.hasOwnProperty(prop)) {\r\n            startProps[prop] = this._currentProps[prop];\r\n        }\r\n        //otherwise, get the current value\r\n        else {\r\n            let startValue = startProps[prop] = this.getPropFromShorthand(prop);\r\n            //go through previous tweens to set the value so that when the timeline loops\r\n            //around, the values are set properly - having each tween know what came before\r\n            //allows us to set to a specific frame without running through the entire timeline\r\n            for (let i = this.length - 1; i >= 0; --i) {\r\n                this[i].startProps[prop] = startValue;\r\n                this[i].endProps[prop] = startValue;\r\n            }\r\n        }\r\n    }\r\n    //create the new Tween and add it to the list\r\n    let tween = new Tween(this.target, startProps, properties, startFrame, duration, ease);\r\n    this.push(tween);\r\n    //update starting values for the next tween - if tweened values included 'p', then Tween\r\n    //parsed that to add additional data that is required\r\n    Object.assign(this._currentProps, tween.endProps);\r\n};\r\n\r\n/**\r\n * Add a single keyframe that doesn't tween.\r\n * @method PIXI.animate.Timeline#addKeyframe\r\n * @param {Object} properties The properties to set.\r\n * @param {int} startFrame The starting frame index.\r\n */\r\np.addKeyframe = function(properties, startFrame) {\r\n    this.extendLastFrame(startFrame - 1);\r\n    let startProps = Object.assign({}, this._currentProps, properties);\r\n    //create the new Tween and add it to the list\r\n    let tween = new Tween(this.target, startProps, null, startFrame, 0);\r\n    this.push(tween);\r\n    Object.assign(this._currentProps, tween.endProps);\r\n};\r\n\r\n/**\r\n * Extend the last frame of the tween.\r\n * @method PIXI.animate.Timeline#extendLastFrame\r\n * @param {int} endFrame The ending frame index.\r\n */\r\np.extendLastFrame = function(endFrame) {\r\n    if (this.length) {\r\n        let prevTween = this[this.length - 1];\r\n        if (prevTween.endFrame < endFrame) {\r\n            if (prevTween.isTweenlessFrame) {\r\n                prevTween.endFrame = endFrame;\r\n            } else {\r\n                this.addKeyframe(\r\n                    this._currentProps,\r\n                    prevTween.endFrame + 1,\r\n                    endFrame - prevTween.endFrame + 1\r\n                );\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Get the value for a property\r\n * @method PIXI.animate.Timeline#getPropFromShorthand\r\n * @param {string} prop\r\n */\r\np.getPropFromShorthand = function(prop) {\r\n    const target = this.target;\r\n    switch (prop) {\r\n        case 'x':\r\n            return target.position.x;\r\n        case 'y':\r\n            return target.position.y;\r\n        case 'sx':\r\n            return target.scale.x;\r\n        case 'sy':\r\n            return target.scale.y;\r\n        case 'kx':\r\n            return target.skew.x;\r\n        case 'ky':\r\n            return target.skew.y;\r\n        case 'r':\r\n            return target.rotation;\r\n        case 'a':\r\n            return target.alpha;\r\n        case 'v':\r\n            return target.visible;\r\n        case 'm':\r\n            return target.mask;\r\n            // case 't':\r\n            //   return target.tint;\r\n            //not sure if we'll actually handle graphics this way?\r\n            //g: return null;\r\n    }\r\n    return null;\r\n};\r\n\r\n// Assign to namespace\r\nexport default Timeline;","/**\r\n * Provide timeline playback of movieclip\r\n * @memberof PIXI.animate\r\n * @class Tween\r\n * @constructor\r\n * @param {PIXI.animate.MovieClip} target The target to play\r\n * @param {Object} startProps The starting properties\r\n * @param {Object} endProps The ending properties\r\n * @param {int} duration Number oframes to tween\r\n * @param {Function} [ease] Ease function to use\r\n */\r\n\r\nclass Tween {\r\n\r\n    constructor(target, startProps, endProps, startFrame, duration, ease) {\r\n\r\n        /**\r\n         * target display object\r\n         * @name PIXI.animate.Tween#target\r\n         * @type {Object}\r\n         */\r\n        this.target = target;\r\n\r\n        /**\r\n         * properties at the start of the tween\r\n         * @type {Object}\r\n         * @name PIXI.animate.Tween#startProps\r\n         */\r\n        this.startProps = startProps;\r\n\r\n        /**\r\n         * properties at the end of the tween, as well as any properties that are set\r\n         * instead of tweened\r\n         * @type {Object}\r\n         * @name PIXI.animate.Tween#endProps\r\n         */\r\n        this.endProps = {};\r\n\r\n        /**\r\n         * duration of tween in frames. For a keyframe with no tweening, the duration will be 0.\r\n         * @type {int}\r\n         * @name PIXI.animate.Tween#duration\r\n         */\r\n        this.duration = duration;\r\n\r\n        /**\r\n         * The frame that the tween starts on\r\n         * @type {int}\r\n         * @name PIXI.animate.Tween#startFrame\r\n         */\r\n        this.startFrame = startFrame;\r\n\r\n        /**\r\n         * the frame that the tween ends on\r\n         * @type {int}\r\n         * @name PIXI.animate.Tween#endFrame\r\n         */\r\n        this.endFrame = startFrame + duration;\r\n\r\n        /**\r\n         * easing function to use, if any\r\n         * @type {Function}\r\n         * @name PIXI.animate.Tween#ease\r\n         */\r\n        this.ease = ease;\r\n\r\n        /**\r\n         * If we don't tween.\r\n         * @type {Boolean}\r\n         * @name PIXI.animate.Tween#isTweenlessFrame\r\n         */\r\n        this.isTweenlessFrame = !endProps;\r\n\r\n\r\n        let prop;\r\n        if (endProps) {\r\n            //make a copy to safely include any unchanged values from the start of the tween\r\n            for (prop in endProps) {\r\n                this.endProps[prop] = endProps[prop];\r\n            }\r\n        }\r\n\r\n        //copy in any starting properties don't change\r\n        for (prop in startProps) {\r\n            if (!this.endProps.hasOwnProperty(prop)) {\r\n                this.endProps[prop] = startProps[prop];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the current frame.\r\n     * @method PIXI.animate.Tween#setPosition\r\n     * @param {int} currentFrame\r\n     */\r\n    setPosition(currentFrame) {\r\n        //if this is a single frame with no tweening, or at the end of the tween, then\r\n        //just speed up the process by setting values\r\n        if (currentFrame >= this.endFrame) {\r\n            this.setToEnd();\r\n            return;\r\n        }\r\n\r\n        if (this.isTweenlessFrame) {\r\n            this.setToEnd();\r\n            return;\r\n        }\r\n\r\n        let time = (currentFrame - this.startFrame) / this.duration;\r\n        if (this.ease) {\r\n            time = this.ease(time);\r\n        }\r\n        let target = this.target;\r\n        let startProps = this.startProps;\r\n        let endProps = this.endProps;\r\n        for (let prop in endProps) {\r\n            let lerp = props[prop];\r\n            if (lerp) {\r\n                setPropFromShorthand(target, prop, lerp(startProps[prop], endProps[prop], time));\r\n            } else {\r\n                setPropFromShorthand(target, prop, startProps[prop]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set to the end position\r\n     * @method PIXI.animate.Tween#setToEnd\r\n     */\r\n    setToEnd() {\r\n        let endProps = this.endProps;\r\n        let target = this.target;\r\n        for (let prop in endProps) {\r\n            setPropFromShorthand(target, prop, endProps[prop]);\r\n        }\r\n    }\r\n}\r\n\r\n//standard tweening\r\nfunction lerpValue(start, end, t) {\r\n    return start + (end - start) * t;\r\n}\r\n\r\nconst props = {\r\n    //position\r\n    x: lerpValue,\r\n    y: lerpValue,\r\n    //scale\r\n    sx: lerpValue,\r\n    sy: lerpValue,\r\n    //skew\r\n    kx: lerpValue,\r\n    ky: lerpValue,\r\n    //rotation\r\n    r: lerpRotation,\r\n    //alpha\r\n    a: lerpValue,\r\n    //tinting\r\n    // t: lerpColor,\r\n    t: null,\r\n    //values to be set\r\n    v: null, //visible\r\n    c: null, //colorTransform\r\n    m: null, //mask\r\n    g: null //not sure if we'll actually handle graphics this way?\r\n};\r\n\r\n//split r, g, b into separate values for tweening\r\n/*function lerpColor(start, end, t)\r\n{\r\n    //split start color into components\r\n    let sR = start >> 16 & 0xFF;\r\n    let sG = start >> 8 & 0xFF;\r\n    let sB = start & 0xFF;\r\n    //split end color into components\r\n    let eR = end >> 16 & 0xFF;\r\n    let eG = end >> 8 & 0xFF;\r\n    let eB = end & 0xFF;\r\n    //lerp red\r\n    let r = sR + (eR - sR) * percent;\r\n    //clamp red to valid values\r\n    if (r < 0)\r\n        r = 0;\r\n    else if (r > 255)\r\n        r = 255;\r\n    //lerp green\r\n    let g = sG + (eG - sG) * percent;\r\n    //clamp green to valid values\r\n    if (g < 0)\r\n        g = 0;\r\n    else if (g > 255)\r\n        g = 255;\r\n    //lerp blue\r\n    let b = sB + (eB - sB) * percent;\r\n    //clamp blue to valid values\r\n    if (b < 0)\r\n        b = 0;\r\n    else if (b > 255)\r\n        b = 255;\r\n\r\n    let combined = (r << 16) | (g << 8) | b;\r\n    return combined;\r\n}*/\r\n\r\nconst PI = Math.PI;\r\nconst TWO_PI = PI * 2;\r\n\r\n//handle 355 -> 5 degrees only going through a 10 degree change instead of\r\n//the long way around\r\n//Math from http://stackoverflow.com/a/2708740\r\nfunction lerpRotation(start, end, t) {\r\n    let difference = Math.abs(end - start);\r\n    if (difference > PI) {\r\n        // We need to add on to one of the values.\r\n        if (end > start) {\r\n            // We'll add it on to start...\r\n            start += TWO_PI;\r\n        } else {\r\n            // Add it on to end.\r\n            end += PI + TWO_PI;\r\n        }\r\n    }\r\n\r\n    // Interpolate it.\r\n    let value = (start + ((end - start) * t));\r\n\r\n    // wrap to 0-2PI\r\n    /*if (value >= 0 && value <= TWO_PI)\r\n        return value;\r\n    return value % TWO_PI;*/\r\n\r\n    //just return, as it's faster\r\n    return value;\r\n}\r\n\r\nfunction setPropFromShorthand(target, prop, value) {\r\n    switch (prop) {\r\n        case \"x\":\r\n            target.transform.position.x = value;\r\n            break;\r\n        case \"y\":\r\n            target.transform.position.y = value;\r\n            break;\r\n        case \"sx\":\r\n            target.transform.scale.x = value;\r\n            break;\r\n        case \"sy\":\r\n            target.transform.scale.y = value;\r\n            break;\r\n        case \"kx\":\r\n            target.transform.skew.x = value;\r\n            break;\r\n        case \"ky\":\r\n            target.transform.skew.y = value;\r\n            break;\r\n        case \"r\":\r\n            target.transform.rotation = value;\r\n            break;\r\n        case \"a\":\r\n            target.alpha = value;\r\n            break;\r\n        case \"t\":\r\n            target.i(value); // i = setTint\r\n            break;\r\n        case \"c\":\r\n            target.c.apply(target, value); // c = setColorTransform\r\n            break;\r\n        case \"v\":\r\n            target.visible = value;\r\n            break;\r\n        case \"m\":\r\n            target.ma(value); // ma = setMask\r\n            break;\r\n    }\r\n}\r\n\r\n// Assign to namespace\r\nexport default Tween;","import load from './load';\r\nimport sound from './sound';\r\nimport utils from './utils';\r\nimport MovieClip from './MovieClip';\r\nimport Scene from './Scene';\r\nimport ShapesCache from './ShapesCache';\r\nimport SymbolLoader from './SymbolLoader';\r\nimport Timeline from './Timeline';\r\nimport Tween from './Tween';\r\nimport Animator from './Animator';\r\nimport AnimatorTimeline from './AnimatorTimeline';\r\n\r\nconst VERSION = __VERSION__;\r\n\r\n/**\r\n * @namespace PIXI.animate\r\n */\r\nexport {\r\n    Animator,\r\n    AnimatorTimeline,\r\n    load,\r\n    sound,\r\n    utils,\r\n    MovieClip,\r\n    Scene,\r\n    ShapesCache,\r\n    SymbolLoader,\r\n    Timeline,\r\n    Tween,\r\n    VERSION\r\n};","/**\r\n * Load the stage class and preload any assets\r\n * @method PIXI.animate.load\r\n * @param {Object} options Options for loading.\r\n * @param {Function} options.stage Reference to the stage class\r\n * @param {Object} [options.stage.assets] Assets used to preload\r\n * @param {PIXI.Container} options.parent The Container to auto-add the stage to.\r\n * @param {String} [options.basePath] Base root directory\r\n * @return {PIXI.loaders.Loader} instance of PIXI resource loader\r\n */\r\n/**\r\n * Load the stage class and preload any assets\r\n * ```\r\n * let renderer = new PIXI.autoDetectRenderer(1280, 720);\r\n * let stage = new PIXI.Container();\r\n * PIXI.animate.load(lib.MyStage, function(instance){\r\n *     stage.addChild(instance);\r\n * });\r\n * function update() {\r\n *      renderer.render(stage);\r\n *      update();\r\n * }\r\n * update();\r\n * ```\r\n * @method PIXI.animate.load\r\n * @param {Function} StageRef Reference to the stage class.\r\n * @param {Object} [StageRef.assets] Assets used to preload.\r\n * @param {Function} complete The callback function when complete.\r\n * @return {PIXI.loaders.Loader} instance of PIXI resource loader\r\n */\r\n/**\r\n * Load the stage class and preload any assets\r\n * ```\r\n * let renderer = new PIXI.autoDetectRenderer(1280, 720);\r\n * let stage = new PIXI.Container();\r\n * PIXI.animate.load(lib.MyStage, stage);\r\n * function update() {\r\n *      renderer.render(stage);\r\n *      update();\r\n * }\r\n * update();\r\n * ```\r\n * @method PIXI.animate.load\r\n * @param {Function} StageRef Reference to the stage class.\r\n * @param {Object} [StageRef.assets] Assets used to preload.\r\n * @param {PIXI.Container} parent The Container to auto-add the stage to.\r\n * @param {String} [basePath] Base root directory\r\n * @return {PIXI.loaders.Loader} instance of PIXI resource loader\r\n */\r\n/**\r\n * Load the stage class and preload any assets\r\n * ```\r\n * let renderer = new PIXI.autoDetectRenderer(1280, 720);\r\n * let stage = new PIXI.Container();\r\n * PIXI.animate.load(lib.MyStage, stage);\r\n * function update() {\r\n *      renderer.render(stage);\r\n *      update();\r\n * }\r\n * update();\r\n * ```\r\n * @method PIXI.animate.load\r\n * @param {Function} StageRef Reference to the stage class.\r\n * @param {Object} [StageRef.assets] Assets used to preload.\r\n * @param {PIXI.Container} parent The Container to auto-add the stage to.\r\n * @param {Function} [complete] The callback function when complete.\r\n * @param {String} [basePath] Base root directory\r\n * @return {PIXI.loaders.Loader} instance of PIXI resource loader\r\n */\r\nconst load = function(options, parent, complete, basePath) {\r\n\r\n    // Support arguments (ref, complete, basePath)\r\n    if (typeof parent === \"function\") {\r\n        basePath = complete;\r\n        complete = parent;\r\n        parent = null;\r\n    } else {\r\n        if (typeof complete === \"string\") {\r\n            basePath = complete;\r\n            complete = null;\r\n        }\r\n    }\r\n\r\n    if (typeof options === \"function\") {\r\n        options = {\r\n            stage: options,\r\n            parent: parent,\r\n            basePath: basePath || \"\",\r\n            complete: complete\r\n        };\r\n    }\r\n\r\n    options = Object.assign({\r\n        stage: null,\r\n        parent: null,\r\n        basePath: '',\r\n        complete: null\r\n    }, options || {});\r\n\r\n    const loader = new PIXI.loaders.Loader();\r\n\r\n    function done() {\r\n        let instance = new options.stage();\r\n        if (options.parent) {\r\n            options.parent.addChild(instance);\r\n        }\r\n        if (options.complete) {\r\n            options.complete(instance, loader);\r\n        }\r\n    }\r\n\r\n    // Check for assets to preload\r\n    let assets = options.stage.assets || {};\r\n    if (assets && Object.keys(assets).length) {\r\n        // assetBaseDir can accept either with trailing slash or not\r\n        let basePath = options.basePath;\r\n        if (basePath) {\r\n            basePath += \"/\";\r\n        }\r\n        for (let id in assets) {\r\n            loader.add(id, basePath + assets[id]);\r\n        }\r\n        loader.once('complete', done).load();\r\n    } else {\r\n        // tiny case where there's only text and no shapes/animations\r\n        done();\r\n    }\r\n\r\n    return loader;\r\n};\r\n\r\nexport default load;\r\n","/**\r\n * @description Event emitter for all sound events. This emits a single\r\n * `play` event which contains the alias, loop and MovieClip which is playing\r\n * the sound.\r\n * @name PIXI.animate.sound\r\n * @type {EventEmitter}\r\n * @example\r\n * \r\n * PIXI.animate.sound.on('play', (alias, loop, context) => {\r\n *    // custom handle sounds being played\r\n *    // where 'alias' is the ID in stage assets\r\n * });\r\n */\r\nexport default new PIXI.utils.EventEmitter();","// If the movieclip plugin is installed\r\nlet _prepare = null;\r\n\r\n/**\r\n * @namespace PIXI.animate.utils\r\n * @description For keyframe conversions\r\n */\r\nexport default class AnimateUtils {\r\n\r\n    /**\r\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\r\n     * @static\r\n     * @method PIXI.animate.utils.hexToUint\r\n     */\r\n    static hexToUint(hex) {\r\n        // Remove the hash\r\n        hex = hex.substr(1);\r\n\r\n        // Convert shortcolors fc9 to ffcc99\r\n        if (hex.length === 3) {\r\n            hex = hex.replace(/([a-f0-9])/g, '$1$1');\r\n        }\r\n        return parseInt(hex, 16);\r\n    }\r\n\r\n    /** \r\n     * Fill frames with booleans of true (showing) and false (hidden).\r\n     * @static\r\n     * @method PIXI.animate.utils.fillFrames\r\n     * @param {Array<Boolean>} timeline\r\n     * @param {int} startFrame The start frame when the timeline shows up\r\n     * @param {int} duration The length of showing\r\n     */\r\n    static fillFrames(timeline, startFrame, duration) {\r\n        //ensure that the timeline is long enough\r\n        const oldLength = timeline.length;\r\n        if (oldLength < startFrame + duration) {\r\n            timeline.length = startFrame + duration;\r\n            //fill any gaps with false to denote that the child should be removed for a bit\r\n            if (oldLength < startFrame) {\r\n                //if the browser has implemented the ES6 fill() function, use that\r\n                if (timeline.fill) {\r\n                    timeline.fill(false, oldLength, startFrame);\r\n                } else {\r\n                    //if we can't use fill, then do a for loop to fill it\r\n                    for (let i = oldLength; i < startFrame; ++i) {\r\n                        timeline[i] = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //if the browser has implemented the ES6 fill() function, use that\r\n        if (timeline.fill) {\r\n            timeline.fill(true, startFrame, startFrame + duration);\r\n        } else {\r\n            const length = timeline.length;\r\n            //if we can't use fill, then do a for loop to fill it\r\n            for (let i = startFrame; i < length; ++i) {\r\n                timeline[i] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert serialized array into keyframes\r\n     * `\"0x100y100 1x150\"` to: `{ \"0\": {\"x\":100, \"y\": 100}, \"1\": {\"x\": 150} }`\r\n     * @static\r\n     * @method PIXI.animate.utils.deserializeKeyframes\r\n     * @param {String} keyframes\r\n     * @param {Object} Resulting keyframes\r\n     */\r\n    static deserializeKeyframes(keyframes) {\r\n        let result = {};\r\n        let i = 0;\r\n        let keysMap = {\r\n            X: 'x', // x position\r\n            Y: 'y', // y position\r\n            A: 'sx', // scale x\r\n            B: 'sy', // scale y\r\n            C: 'kx', // skew x\r\n            D: 'ky', // skew y\r\n            R: 'r', // rotation\r\n            L: 'a', // alpha\r\n            T: 't', // tint\r\n            F: 'c', // colorTransform\r\n            V: 'v' // visibility\r\n        };\r\n        let c,\r\n            buffer = '',\r\n            isFrameStarted = false,\r\n            prop,\r\n            frame = {};\r\n\r\n        while (i <= keyframes.length) {\r\n            c = keyframes[i];\r\n            if (keysMap[c]) {\r\n                if (!isFrameStarted) {\r\n                    isFrameStarted = true;\r\n                    result[buffer] = frame;\r\n                }\r\n                if (prop) {\r\n                    frame[prop] = this.parseValue(prop, buffer);\r\n                }\r\n                prop = keysMap[c];\r\n                buffer = '';\r\n                i++;\r\n            }\r\n            // Start a new prop\r\n            else if (!c || c === ' ') {\r\n                i++;\r\n                frame[prop] = this.parseValue(prop, buffer);\r\n                buffer = '';\r\n                prop = null;\r\n                frame = {};\r\n                isFrameStarted = false;\r\n            } else {\r\n                buffer += c;\r\n                i++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Convert serialized shapes into draw commands for PIXI.Graphics.\r\n     * @static\r\n     * @method PIXI.animate.utils.deserializeShapes\r\n     * @param {String} str\r\n     * @param {Array} Resulting shapes map\r\n     */\r\n    static deserializeShapes(str) {\r\n        const result = [];\r\n        // each shape is a new line\r\n        let shapes = str.split(\"\\n\");\r\n        let isCommand = /^[a-z]{1,2}$/;\r\n        for (let i = 0; i < shapes.length; i++) {\r\n            let shape = shapes[i].split(' '); // arguments are space separated\r\n            for (let j = 0; j < shape.length; j++) {\r\n                // Convert all numbers to floats, ignore colors\r\n                let arg = shape[j];\r\n                if (arg[0] !== '#' && !isCommand.test(arg)) {\r\n                    shape[j] = parseFloat(arg);\r\n                }\r\n            }\r\n            result.push(shape);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /** \r\n     * Parse the value of the compressed keyframe.\r\n     * @method PIXI.animate.utils.parseValue\r\n     * @static\r\n     * @private\r\n     * @param {String} prop The property key\r\n     * @param {String} buffer The contents\r\n     * @return {*} The parsed value\r\n     */\r\n    static parseValue(prop, buffer) {\r\n        switch (prop) {\r\n            // Color transforms are parsed as an array\r\n            case 'c':\r\n                {\r\n                    buffer = buffer.split(',');\r\n                    buffer.forEach(function(val, i, buffer) {\r\n                        buffer[i] = parseFloat(val);\r\n                    });\r\n                    return buffer;\r\n                }\r\n                // Tint value should not be converted\r\n                // can be color uint or string\r\n            case 't':\r\n                {\r\n                    return buffer;\r\n                }\r\n                // The visiblity parse as boolean\r\n            case 'v':\r\n                {\r\n                    return !!parseInt(buffer);\r\n                }\r\n                // Everything else parse a floats\r\n            default:\r\n                {\r\n                    return parseFloat(buffer);\r\n                }\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Upload all the textures and graphics to the GPU. \r\n     * @method PIXI.animate.utils.upload\r\n     * @static\r\n     * @param {PIXI.WebGLRenderer} renderer Render to upload to\r\n     * @param {PIXI.DisplayObject} clip MovieClip to upload\r\n     * @param {function} done When complete\r\n     */\r\n    static upload(renderer, displayObject, done) {\r\n        if (!_prepare) {\r\n            _prepare = renderer.plugins.prepare;\r\n            _prepare.register(this.addMovieClips);\r\n        }\r\n        _prepare.upload(displayObject, done);\r\n    }\r\n\r\n    /**\r\n     * Add movie clips to the upload prepare.\r\n     * @method PIXI.animate.utils.addMovieClips\r\n     * @static\r\n     * @private\r\n     * @param {*} item To add to the queue \r\n     */\r\n    static addMovieClips(item) {\r\n        if (item instanceof PIXI.animate.MovieClip) {\r\n            item._timedChildTimelines.forEach((timeline) => {\r\n                const index = item.children.indexOf(timeline.target);\r\n                if (index === -1) {\r\n                    _prepare.add(timeline.target);\r\n                }\r\n            });\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}","/**\r\n * Mixins for the PIXI.Container class.\r\n * @class Container\r\n * @memberof PIXI\r\n */\r\nconst p = PIXI.Container.prototype;\r\n\r\n/**\r\n * Shortcut for `addChild`.\r\n * @method PIXI.Container#ac\r\n * @param {*} [child*] N-number of children\r\n * @return {PIXI.DisplayObject} Instance of first child added\r\n */\r\np.ac = p.addChild;\r\n\r\n/**\r\n * Extend a container\r\n * @method PIXI.Container.extend\r\n * @static\r\n * @param {PIXI.Container} child The child function\r\n * @return {PIXI.Container} THe child\r\n */\r\n/**\r\n * Extend a container (shortcut for `extend`)\r\n * @method PIXI.Container.e\r\n * @static\r\n * @param {PIXI.Container} child The child function\r\n * @return {PIXI.Container} THe child\r\n */\r\nPIXI.Container.extend = PIXI.Container.e = function(child) {\r\n    child.prototype = Object.create(p);\r\n    child.prototype.__parent = p;\r\n    child.prototype.constructor = child;\r\n    return child;\r\n};","import utils from '../animate/utils';\r\n\r\n/**\r\n * Mixins for the PIXI.DisplayObject class.\r\n * @memberof PIXI\r\n * @class DisplayObject\r\n */\r\nconst p = PIXI.DisplayObject.prototype;\r\n\r\n// Color Matrix filter\r\nlet ColorMatrixFilter;\r\nif (PIXI.filters) {\r\n    ColorMatrixFilter = PIXI.filters.ColorMatrixFilter;\r\n}\r\n\r\n/**\r\n * Function to see if this is renderable or not. Useful for setting masks.\r\n * @method PIXI.DisplayObject#setRenderable\r\n * @param  {Boolean} [renderable=false] Make renderable\r\n * @return {PIXI.DisplayObject}\r\n */\r\n/**\r\n * Shortcut to `setRenderable`.\r\n * @method PIXI.DisplayObject#re\r\n * @param  {Boolean} [renderable=false] Make renderable\r\n * @return {PIXI.DisplayObject}\r\n */\r\np.setRenderable = p.re = function(renderable) {\r\n    this.renderable = !!renderable;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Shortcut for `setTransform`.\r\n * @method PIXI.DisplayObject#tr\r\n * @param {Number} x The X position\r\n * @param {Number} y The Y position\r\n * @param {Number} scaleX The X Scale value\r\n * @param {Number} scaleY The Y Scale value\r\n * @param {Number} skewX The X skew value\r\n * @param {Number} skewY The Y skew value\r\n * @param {Number} pivotX The X pivot value\r\n * @param {Number} pivotY The Y pivot value\r\n * @return {PIXI.DisplayObject} Instance for chaining\r\n */\r\np.t = p.setTransform;\r\n\r\n/**\r\n * Setter for mask to be able to chain.\r\n * @method PIXI.DisplayObject#setMask\r\n * @param {PIXI.Graphics} mask The mask shape to use\r\n * @return {PIXI.DisplayObject} Instance for chaining\r\n */\r\n/**\r\n * Shortcut for `setMask`.\r\n * @method PIXI.DisplayObject#ma\r\n * @param {PIXI.Sprite|PIXI.Graphics} mask The mask shape to use\r\n * @return {PIXI.DisplayObject} Instance for chaining\r\n */\r\np.setMask = p.ma = function(mask) {\r\n    // According to PIXI, only Graphics and Sprites can \r\n    // be used as mask, let's ignore everything else, like other\r\n    // movieclips and displayobjects/containers\r\n    if (mask) {\r\n        if (!(mask instanceof PIXI.Graphics) && !(mask instanceof PIXI.Sprite)) {\r\n            if (typeof console !== \"undefined\" && console.warn) {\r\n                console.warn(\"Warning: Masks can only be PIXI.Graphics or PIXI.Sprite objects.\");\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    this.mask = mask;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Setter for the alpha\r\n * @method PIXI.DisplayObject#setAlpha\r\n * @param {Number} alpha The alpha amount to use, from 0 to 1\r\n * @return {PIXI.DisplayObject} Instance for chaining\r\n */\r\n/**\r\n * Shortcut for `setAlpha`.\r\n * @method PIXI.DisplayObject#a\r\n * @param {Number} alpha The alpha amount to use, from 0 to 1\r\n * @return {PIXI.DisplayObject} Instance for chaining\r\n */\r\np.setAlpha = p.a = function(alpha) {\r\n    this.alpha = alpha;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Set the tint values by color.\r\n * @method PIXI.DisplayObject#setTint\r\n * @param {int} tint The color value to tint\r\n * @return {PIXI.DisplayObject} Object for chaining\r\n */\r\n/**\r\n * Shortcut to `setTint`.\r\n * @method PIXI.DisplayObject#tn\r\n * @param {Number|String} tint The red percentage value\r\n * @return {PIXI.DisplayObject} Object for chaining\r\n */\r\np.setTint = p.i = function(tint) {\r\n    if (typeof tint === \"string\") {\r\n        tint = utils.hexToUint(tint);\r\n    }\r\n    // this.tint = tint\r\n    // return this;\r\n    // TODO: Replace with DisplayObject.tint setter\r\n    // once the functionality is added to Pixi.js, for\r\n    // now we'll use the slower ColorMatrixFilter to handle\r\n    // the color transformation\r\n    var r = tint >> 16 & 0xFF;\r\n    var g = tint >> 8 & 0xFF;\r\n    var b = tint & 0xFF;\r\n    return this.c(r / 255, 0, g / 255, 0, b / 255, 0);\r\n};\r\n\r\n/**\r\n * Set additive and multiply color, tinting\r\n * @method PIXI.DisplayObject#setColorTransform\r\n * @param {Number} r The multiply red value\r\n * @param {Number} rA The additive red value\r\n * @param {Number} g The multiply green value\r\n * @param {Number} gA The additive green value\r\n * @param {Number} b The multiply blue value\r\n * @param {Number} bA The additive blue value\r\n * @return {PIXI.DisplayObject} Object for chaining\r\n */\r\n/**\r\n * Shortcut to `setColor`.\r\n * @method PIXI.DisplayObject#c\r\n * @param {Number} r The multiply red value\r\n * @param {Number} rA The additive red value\r\n * @param {Number} g The multiply green value\r\n * @param {Number} gA The additive green value\r\n * @param {Number} b The multiply blue value\r\n * @param {Number} bA The additive blue value\r\n * @return {PIXI.DisplayObject} Object for chaining\r\n */\r\np.setColorTransform = p.c = function(r, rA, g, gA, b, bA) {\r\n    var filter = this.colorTransformFilter;\r\n    filter.matrix[0] = r;\r\n    filter.matrix[4] = rA;\r\n    filter.matrix[6] = g;\r\n    filter.matrix[9] = gA;\r\n    filter.matrix[12] = b;\r\n    filter.matrix[14] = bA;\r\n    this.filters = [filter];\r\n    return this;\r\n};\r\n\r\n/**\r\n * The current default color transforming filters\r\n * @name {PIXI.filters.ColorMatrixFilter} PIXI.DisplayObject#colorTransformFilter\r\n */\r\nif (!p.hasOwnProperty('colorTransformFilter')) {\r\n    Object.defineProperty(p, 'colorTransformFilter', {\r\n        set: function(filter) {\r\n            this._colorTransformFilter = filter;\r\n        },\r\n        get: function() {\r\n            return this._colorTransformFilter || new ColorMatrixFilter();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Extend a container\r\n * @method PIXI.DisplayObject.extend\r\n * @static\r\n * @param {PIXI.DisplayObject} child The child function\r\n * @return {PIXI.DisplayObject} THe child\r\n */\r\n/**\r\n * Extend a container (shortcut for `extend`)\r\n * @method PIXI.DisplayObject.e\r\n * @static\r\n * @param {PIXI.DisplayObject} child The child function\r\n * @return {PIXI.DisplayObject} THe child\r\n */\r\nPIXI.DisplayObject.extend = PIXI.DisplayObject.e = function(child) {\r\n    child.prototype = Object.create(p);\r\n    child.prototype.__parent = p;\r\n    child.prototype.constructor = child;\r\n    return child;\r\n};","/**\r\n * Mixins for the PIXI.Graphics class.\r\n * @memberof PIXI\r\n * @class Graphics\r\n */\r\nconst p = PIXI.Graphics.prototype;\r\n\r\n/**\r\n * Shortcut for `drawCommands`.\r\n * @method PIXI.Graphics#d\r\n * @param  {Array} commands The commands and parameters to draw\r\n * @return {PIXI.Graphics}\r\n */\r\n/**\r\n * Execute a series of commands, this is the name of the short function\r\n * followed by the parameters, e.g., `[\"f\", \"#ff0000\", \"r\", 0, 0, 100, 200]`\r\n * @method PIXI.Graphics#drawCommands\r\n * @param  {Array} commands The commands and parameters to draw\r\n * @return {PIXI.Graphics}\r\n */\r\np.drawCommands = p.d = function(commands) {\r\n    var currentCommand, params = [],\r\n        i = 0;\r\n\r\n    while (i <= commands.length) {\r\n        var item = commands[i++];\r\n        if (item === undefined || this[item]) {\r\n            if (currentCommand) {\r\n                this[currentCommand].apply(this, params);\r\n                params.length = 0;\r\n            }\r\n            currentCommand = item;\r\n        } else {\r\n            params.push(item);\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified\r\n * since the fill or stroke was last set.\r\n * @method PIXI.Graphics#c\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.c = p.closePath;\r\n\r\n/**\r\n * Alias for `addHole`\r\n * @method PIXI.Graphics#h\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.h = p.addHole;\r\n\r\n/**\r\n * Shortcut to `moveTo`.\r\n * @method PIXI.Graphics#m\r\n * @param {Number} x The x coordinate the drawing point should move to.\r\n * @param {Number} y The y coordinate the drawing point should move to.\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls).\r\n **/\r\np.m = p.moveTo;\r\n\r\n/**\r\n * Shortcut to `lineTo`.\r\n * @method PIXI.Graphics#l\r\n * @param {Number} x The x coordinate the drawing point should draw to.\r\n * @param {Number} y The y coordinate the drawing point should draw to.\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.l = p.lineTo;\r\n\r\n/**\r\n * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy). For detailed\r\n * information, read the <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\">\r\n * whatwg spec</a>. A tiny API method \"qt\" also exists.\r\n * @method PIXI.Graphics#q\r\n * @param {Number} cpx\r\n * @param {Number} cpy\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.q = p.quadraticCurveTo;\r\n\r\n/**\r\n * Shortcut to `bezierCurveTo`.\r\n * @method PIXI.Graphics#b\r\n * @param {Number} cp1x\r\n * @param {Number} cp1y\r\n * @param {Number} cp2x\r\n * @param {Number} cp2y\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.b = p.bezierCurveTo;\r\n\r\n/**\r\n * Shortcut to `beginFill`.\r\n * @method PIXI.Graphics#f\r\n * @param {Uint} color The hex color value (e.g. 0xFFFFFF)\r\n * null will result in no fill.\r\n * @param {Number} [alpha=1] The alpha value of fill\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.f = p.beginFill;\r\n\r\n/**\r\n * Shortcut to `lineStyle`.\r\n * @method PIXI.Graphics#s\r\n * @param {String} color A CSS compatible color value (ex. \"#FF0000\", \"red\", or \"rgba(255,0,0,0.5)\"). Setting to\r\n * null will result in no stroke.\r\n * @param {Number} [thickness=1] The thickness of the stroke\r\n * @param {Number} [alpha=1] The alpha value from 0 (invisibile) to 1 (visible)\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.s = p.lineStyle;\r\n\r\n/**\r\n * Shortcut to `drawRect`.\r\n * @method PIXI.Graphics#dr\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @param {Number} w Width of the rectangle\r\n * @param {Number} h Height of the rectangle\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\n/**\r\n * Shortcut to `drawRect`.\r\n * @method PIXI.Graphics#r\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @param {Number} w Width of the rectangle\r\n * @param {Number} h Height of the rectangle\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.dr = p.drawRect;\r\n\r\n/**\r\n * Shortcut to `drawRoundedRect`.\r\n * @method PIXI.Graphics#rr\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @param {Number} w Width of the rectangle\r\n * @param {Number} h Height of the rectangle\r\n * @param {Number} radius The corner radius\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.rr = p.drawRoundedRect;\r\n\r\n/**\r\n * Shortcut to `drawRoundedRect`.\r\n * @method PIXI.Graphics#rc\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @param {Number} w Width of the rectangle\r\n * @param {Number} h Height of the rectangle\r\n * @param {Number} radiusTL The top left corner radius\r\n * @param {Number} radiusTR The top right corner radius\r\n * @param {Number} radiusBR The bottom right corner radius\r\n * @param {Number} radiusBL The bottom left corner radius\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.rc = p.drawRoundedRect;\r\n\r\n/**\r\n * Shortcut to `drawCircle`.\r\n * @method PIXI.Graphics#dc\r\n * @param {Number} x x coordinate center point of circle.\r\n * @param {Number} y y coordinate center point of circle.\r\n * @param {Number} radius Radius of circle.\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.dc = p.drawCircle;\r\n\r\n/**\r\n * Shortcut to `arc`.\r\n * @method PIXI.Graphics#ac\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @param {Number} radius\r\n * @param {Number} startAngle Measured in radians.\r\n * @param {Number} endAngle Measured in radians.\r\n * @param {Boolean} anticlockwise\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.ar = p.arc;\r\n\r\n/**\r\n * Shortcut to `arcTo`.\r\n * @method PIXI.Graphics#at\r\n * @param {Number} x1\r\n * @param {Number} y1\r\n * @param {Number} x2\r\n * @param {Number} y2\r\n * @param {Number} radius\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.at = p.arcTo;\r\n\r\n/**\r\n * Shortcut to `drawEllipse`.\r\n * @method  PIXI.Graphics#de\r\n * @param  {Number} x      [description]\r\n * @param  {Number} y      [description]\r\n * @param  {Number} width  [description]\r\n * @param  {Number} height [description]\r\n */\r\np.de = p.drawEllipse;\r\n\r\n/**\r\n * Placeholder method for a linear fill. Pixi does not support linear fills,\r\n * so we just pick the first color in colorArray\r\n * @method PIXI.Graphics#lf\r\n * @param {Array} colorArray An array of CSS compatible color values @see `f`\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.lf = function(colorArray) {\r\n    // @if DEBUG\r\n    console.warn(\"Linear gradient fills are not supported\");\r\n    // @endif\r\n    return this.f(colorArray[0]);\r\n};\r\n\r\n/**\r\n * Placeholder method for a radial fill. Pixi does not support radial fills,\r\n * so we just pick the first color in colorArray\r\n * @method PIXI.Graphics#rf\r\n * @param {Array} colorArray An array of CSS compatible color values @see `f`\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.rf = function(colorArray) {\r\n    // @if DEBUG\r\n    console.warn(\"Radial gradient fills are not supported\");\r\n    // @endif\r\n    return this.f(colorArray[0]);\r\n};\r\n\r\n/**\r\n * Placeholder method for a `beginBitmapFill`. Pixi does not support bitmap fills.\r\n * @method PIXI.Graphics#bf\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.bf = function() {\r\n    // @if DEBUG\r\n    console.warn(\"Bitmap fills are not supported\");\r\n    // @endif\r\n    return this.f(0x0);\r\n};\r\n\r\n/**\r\n * Placeholder method for a `setStrokeDash`. Pixi does not support dashed strokes.\r\n * @method PIXI.Graphics#sd\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.sd = function() {\r\n    // @if DEBUG\r\n    console.warn(\"Dashed strokes are not supported\");\r\n    // @endif\r\n    return this;\r\n};\r\n\r\n/**\r\n * Placeholder method for a `beginBitmapStroke`. Pixi does not support bitmap strokes.\r\n * @method PIXI.Graphics#bs\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.bs = function() {\r\n    // @if DEBUG\r\n    console.warn(\"Bitmap strokes are not supported\");\r\n    // @endif\r\n    return this;\r\n};\r\n\r\n/**\r\n * Placeholder method for a `beginLinearGradientStroke`. Pixi does not support gradient strokes.\r\n * @method PIXI.Graphics#ls\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.ls = function() {\r\n    // @if DEBUG\r\n    console.warn(\"Linear gradient strokes are not supported\");\r\n    // @endif\r\n    return this;\r\n};\r\n\r\n/**\r\n * Placeholder method for a `beginRadialGradientStroke`. Pixi does not support gradient strokes.\r\n * @method PIXI.Graphics#rs\r\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\r\n **/\r\np.rs = function() {\r\n    // @if DEBUG\r\n    console.warn(\"Radial gradient strokes are not supported\");\r\n    // @endif\r\n    return this;\r\n};","/**\r\n * Mixins for the PIXI.Sprite class.\r\n * @memberof PIXI\r\n * @class Sprite\r\n */\r\nconst p = PIXI.Sprite.prototype;\r\n\r\n/**\r\n * Extend a container\r\n * @method PIXI.Sprite.extend\r\n * @static\r\n * @param {PIXI.Sprite} child The child function\r\n * @return {PIXI.Sprite} THe child\r\n */\r\n/**\r\n * Extend a container (shortcut for `extend`)\r\n * @method PIXI.Sprite.e\r\n * @static\r\n * @param {PIXI.Sprite} child The child function\r\n * @return {PIXI.Sprite} THe child\r\n */\r\nPIXI.Sprite.extend = PIXI.Sprite.e = function(child) {\r\n    child.prototype = Object.create(p);\r\n    child.prototype.__parent = p;\r\n    child.prototype.constructor = child;\r\n    return child;\r\n};","/**\r\n * Mixins for the PIXI.Text class.\r\n * @memberof PIXI\r\n * @class Text\r\n */\r\nconst p = PIXI.Text.prototype;\r\n\r\n// Possible align values\r\nconst ALIGN_VALUES = [\"center\", \"right\"];\r\n\r\n/**\r\n * Setter for the alignment, also sets the anchor point\r\n * to make sure the positioning is correct.\r\n * @method PIXI.Text#setAlign\r\n * @param {String} align Either, center, right, left\r\n * @return {PIXI.Text} For chaining\r\n */\r\n/**\r\n * Shortcut for `setAlign`.\r\n * @method PIXI.Text#g\r\n * @param {String|int} align Either, center (0), right (1), left (-1)\r\n * @return {PIXI.Text} For chaining\r\n */\r\np.setAlign = p.g = function(align) {\r\n    if (typeof align == \"string\") {\r\n        align = ALIGN_VALUES.indexOf(align);\r\n    }\r\n    this.style.align = ALIGN_VALUES[align] || \"left\";\r\n    this.anchor.x = (align + 1) / 2;\r\n    return this;\r\n};\r\n\r\n// Map of short names to long names\r\nvar STYLE_PROPS = {\r\n    o: 'font', // TODO: deprecate in Pixi v4\r\n    z: 'fontSize',\r\n    f: 'fontFamily',\r\n    y: 'fontStyle',\r\n    g: 'fontWeight',\r\n    i: 'fill',\r\n    a: 'align',\r\n    s: 'stroke',\r\n    t: 'strokeThickness',\r\n    w: 'wordWrap',\r\n    d: 'wordWrapWidth',\r\n    l: 'lineHeight',\r\n    h: 'dropShadow',\r\n    c: 'dropShadowColor',\r\n    n: 'dropShadowAngle',\r\n    b: 'dropShadowBlur',\r\n    p: 'padding',\r\n    x: 'textBaseline',\r\n    j: 'lineJoin',\r\n    m: 'miterLimit',\r\n    e: 'letterSpacing'\r\n};\r\n\r\n/**\r\n * Set the style, a chainable version of style setter\r\n * @method PIXI.Text#setStyle\r\n * @param {Object} style\r\n * @return {PIXI.Text} instance of text field\r\n */\r\n/**\r\n * Shortcut for `setStyle`.\r\n * @method PIXI.Text#ss\r\n * @param {Object} style\r\n * @return {PIXI.Text} instance of text field\r\n */\r\np.setStyle = p.ss = function(style) {\r\n    // Replace short STYLE_PROPS with long names\r\n    for (var k in STYLE_PROPS) {\r\n        if (style[k] !== undefined) {\r\n            style[STYLE_PROPS[k]] = style[k];\r\n            delete style[k];\r\n        }\r\n    }\r\n    this.style = style;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Initial setting of the drop shadow.\r\n * @method PIXI.Text#setShadow\r\n * @param {String} [color=\"#000000\"] The color to set\r\n * @param {Number} [angle=Math.PI/4] The angle of offset, in radians\r\n * @param {Number} [distance=5] The offset distance\r\n * @return {PIXI.Text} For chaining\r\n */\r\n/**\r\n * Shortcut for `setShadow`.\r\n * @method PIXI.Text#sh\r\n * @param {String} [color=\"#000000\"] The color to set\r\n * @param {Number} [angle=Math.PI/4] The angle of offset, in radians\r\n * @param {Number} [distance=5] The offset distance\r\n * @return {PIXI.Text} For chaining\r\n */\r\np.setShadow = p.sh = function(color, angle, distance) {\r\n    var style = this.style;\r\n    style.dropShadow = true;\r\n\r\n    // Convert color to hex string\r\n    if (color !== undefined) {\r\n        color = \"#\" + color.toString(16);\r\n    }\r\n    style.dropShadowColor = isUndefinedOr(color, style.dropShadowColor);\r\n    style.dropShadowAngle = isUndefinedOr(angle, style.dropShadowAngle);\r\n    style.dropShadowDistance = isUndefinedOr(distance, style.dropShadowDistance);\r\n    return this;\r\n};\r\n\r\n/**\r\n * Check if a value is undefined, fallback to default value\r\n * @method isUndefinedOr\r\n * @private\r\n * @param {*} value The value to check\r\n * @param {*} defaultValue The default value if value is undefined\r\n * @return {*} The either the value or the default value\r\n */\r\nvar isUndefinedOr = function(value, defaultValue) {\r\n    return value === undefined ? defaultValue : value;\r\n};\r\n","import Container from './Container';\r\nimport DisplayObject from './DisplayObject';\r\nimport Sprite from './Sprite';\r\nimport Graphics from './Graphics';\r\nimport Text from './Text';\r\n\r\n/**\r\n * @namespace PIXI\r\n */\r\nexport default {\r\n    Container,\r\n    DisplayObject,\r\n    Sprite,\r\n    Graphics,\r\n    Text\r\n};","// If we're in the browser make sure PIXI is available\r\nif (typeof PIXI === 'undefined') {\r\n    throw \"Requires PIXI\";\r\n}\r\n\r\nif (!PIXI.animate) {\r\n    // Include the PIXI mixins\r\n    require('./mixins');\r\n\r\n    // Add to the PIXI global object\r\n    Object.defineProperty(PIXI, 'animate', {\r\n        enumerable: true,\r\n        get() { return require('./animate'); }\r\n    });\r\n}\r\n\r\n// Export for Node-compatible environments like Electron\r\nif (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = PIXI.animate;\r\n}\r\n"],"sourceRoot":"."}